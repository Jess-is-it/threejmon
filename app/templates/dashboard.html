{% extends "base.html" %}
{% block title %}Dashboard{% endblock %}
{% block header_title %}Dashboard{% endblock %}
{% block header_badge %}
  <span class="badge bg-blue-lt text-blue header-icon-badge"><i class="ti ti-dashboard"></i></span>
{% endblock %}
{% block content %}
{% if message %}
  <div class="alert alert-info">{{ message }}</div>
{% endif %}

<div class="row row-cards">
  <div class="col-md-6 col-xl-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <span class="avatar bg-blue-lt me-3"><i class="ti ti-sun"></i></span>
          <div>
            <div class="fw-semibold">Optical Monitor</div>
            {% set status = job_status.get('optical') %}
            <div class="text-muted">{{ 'attention' if status and status.last_error else 'ok' }}</div>
          </div>
        </div>
        <div class="mt-3 text-muted small">
          <div>Last run: {{ status.last_run_at_ph if status else 'never' }}</div>
          <div>Last success: {{ status.last_success_at_ph if status else 'never' }}</div>
          <div>Last error: {{ status.last_error if status and status.last_error else 'none' }}</div>
        </div>
      </div>
    </div>
  </div>
  <div class="col-md-6 col-xl-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <span class="avatar bg-purple-lt me-3"><i class="ti ti-tower"></i></span>
          <div>
            <div class="fw-semibold">RTO Monitor</div>
            {% set status = job_status.get('rto') %}
            <div class="text-muted">{{ 'attention' if status and status.last_error else 'ok' }}</div>
          </div>
        </div>
        <div class="mt-3 text-muted small">
          <div>Last run: {{ status.last_run_at_ph if status else 'never' }}</div>
          <div>Last success: {{ status.last_success_at_ph if status else 'never' }}</div>
          <div>Last error: {{ status.last_error if status and status.last_error else 'none' }}</div>
        </div>
      </div>
    </div>
  </div>
  <div class="col-md-6 col-xl-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <span class="avatar bg-green-lt me-3"><i class="ti ti-activity"></i></span>
          <div>
            <div class="fw-semibold">ISP Pulsewatch</div>
            <div class="text-muted">Pulse + Speedtests</div>
          </div>
        </div>
        {% set pulse_state = isp_state.get('pulsewatch', {}) %}
        <div class="mt-3 text-muted small">
          <div>Enabled: {{ 'yes' if pulse_enabled else 'no' }}</div>
          <div>Address-list sync: {{ 'on' if isp_settings.pulsewatch.manage_address_lists else 'off' }}</div>
          <div>Last reconcile: {{ pulse_last_reconcile or 'n/a' }}</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="row row-cards mt-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header d-flex align-items-center">
        <h3 class="card-title">Pulsewatch Stability Overview</h3>
        <div class="ms-auto">
          <select class="form-select form-select-sm" id="pulsewatch-stability-days" style="min-width: 140px;">
            {% set pie_days = isp_settings.pulsewatch.dashboard.pie_default_days %}
            <option value="1h">Last 1h</option>
            <option value="6h">Last 6h</option>
            <option value="12h">Last 12h</option>
            <option value="1d" {% if pie_days == 1 %}selected{% endif %}>Last 1 day</option>
            <option value="7d" {% if pie_days == 7 %}selected{% endif %}>Last 7 days</option>
            <option value="15d" {% if pie_days == 15 %}selected{% endif %}>Last 15 days</option>
            <option value="30d" {% if pie_days == 30 %}selected{% endif %}>Last 30 days</option>
          </select>
        </div>
      </div>
      <div class="card-body">
        <div id="pulsewatch-stability-grid" class="d-grid" style="gap: 6px; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); justify-items: start;"></div>
        <div class="pulsewatch-stability-legend mt-3 justify-content-end">
          <div class="d-flex align-items-center gap-2 small text-muted">
            <span style="width:10px;height:10px;border-radius:50%;background:#2fb344;display:inline-block;"></span>
            <span>Stable</span>
          </div>
          <div class="d-flex align-items-center gap-2 small text-muted">
            <span style="width:10px;height:10px;border-radius:50%;background:#f59f00;display:inline-block;"></span>
            <span>Unstable</span>
          </div>
          <div class="d-flex align-items-center gap-2 small text-muted">
            <span style="width:10px;height:10px;border-radius:50%;background:#e03131;display:inline-block;"></span>
            <span>Critical</span>
          </div>
          <div class="d-flex align-items-center gap-2 small text-muted">
            <span style="width:10px;height:10px;border-radius:50%;background:#f76707;display:inline-block;"></span>
            <span>Down</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="row row-cards mt-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <div class="row g-2 align-items-center w-100">
          <div class="col-12 col-lg-4">
            <h3 class="card-title mb-0">Pulsewatch Latency Trend</h3>
          </div>
          <div class="col-12 col-lg-8">
            <div class="d-flex align-items-center gap-2 flex-nowrap justify-content-lg-end">
              <span class="text-muted small">Filter core</span>
              <select class="form-select form-select-sm" id="pulsewatch-core-filter" style="min-width: 160px;">
                <option value="all">All cores</option>
                {% for core in isp_settings.pulsewatch.mikrotik.cores %}
                  <option value="{{ core.id }}">{{ core.label }}</option>
                {% endfor %}
              </select>
              <span class="text-muted small">Range</span>
              <select class="form-select form-select-sm" id="pulsewatch-range-filter" style="min-width: 120px;">
                <option value="6">Last 6h</option>
                <option value="12">Last 12h</option>
                <option value="24" selected>Last 24h</option>
              </select>
              <span class="text-muted small">Target</span>
              <select class="form-select form-select-sm" id="pulsewatch-target-filter" style="min-width: 140px;">
                <option value="all">All targets</option>
                {% for target in pulse_targets %}
                  <option value="{{ target }}">{{ target }}</option>
                {% endfor %}
              </select>
              <span class="text-muted small">From</span>
              <input class="form-control form-control-sm" id="pulsewatch-from-filter" type="datetime-local" style="min-width: 190px;">
              <span class="text-muted small">To</span>
              <input class="form-control form-control-sm" id="pulsewatch-to-filter" type="datetime-local" style="min-width: 190px;">
            </div>
          </div>
        </div>
      </div>
      <div class="card-body">
        <div class="text-muted small mb-2">Vertical: latency (ms) Â· Horizontal: time (PHT)</div>
        <div id="pulsewatch-latency-chart" style="width: 100%; height: 260px; position: relative;"></div>
        <div id="pulsewatch-latency-legend" class="mt-3 d-flex flex-wrap gap-3"></div>
      </div>
    </div>
  </div>
</div>

<div class="row row-cards mt-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header d-flex align-items-center">
        <h3 class="card-title">Pulsewatch ISP Summary</h3>
        <div class="ms-auto">
          <select class="form-select form-select-sm" id="pulsewatch-summary-target" style="min-width: 180px;">
            <option value="all" {% if pulse_summary_target == "all" %}selected{% endif %}>Target: All</option>
            {% for target in pulse_targets %}
              <option value="{{ target }}" {% if pulse_summary_target == target %}selected{% endif %}>Target: {{ target }}</option>
            {% endfor %}
          </select>
        </div>
      </div>
      <div class="card-body">
          <div class="row mb-4">
            <div class="col-sm-6 col-xl-3 mb-3">
              <div class="border rounded p-3 h-100">
                <div class="text-muted small">Total ISPs</div>
                <div class="fs-3 fw-semibold" id="pulsewatch-summary-total">{{ pulse_total }}</div>
              </div>
            </div>
            <div class="col-sm-6 col-xl-3 mb-3">
              <div class="border rounded p-3 h-100">
                <div class="text-muted small">Last Pulsewatch Check</div>
                <div class="fs-4 fw-semibold" id="pulsewatch-summary-last">{{ pulse_last_check or 'n/a' }}</div>
              </div>
            </div>
          </div>

        {% if pulse_rows %}
          <div style="overflow-x:auto;">
            <table class="table table-vcenter">
              <thead>
                <tr>
                  <th>ISP</th>
                  <th>Source IP</th>
                  <th>Last Check</th>
                  <th>Loss Max</th>
                  <th>Avg Max</th>
                  <th>Loss History</th>
                  <th>Downtime</th>
                  <th>Last Speedtest</th>
                </tr>
              </thead>
              <tbody id="pulsewatch-summary-body" data-loss-minutes="{{ pulse_summary_loss_minutes }}" data-refresh="{{ pulse_summary_refresh }}">
                {% for row in pulse_rows %}
                  <tr>
                    <td class="fw-semibold">{{ row.label }}</td>
                    <td>{{ row.source_ip or 'n/a' }}</td>
                    <td>{{ row.last_check or 'n/a' }}</td>
                    <td>{{ row.loss_max if row.loss_max is not none else 'n/a' }}%</td>
                    <td>{{ row.avg_max if row.avg_max is not none else 'n/a' }}ms</td>
                    <td>
                      {% if row.loss_points %}
                        <svg width="120" height="30" viewBox="0 0 120 30">
                          <polyline points="{{ row.loss_points }}" fill="none" stroke="#2fb344" stroke-width="2" />
                        </svg>
                      {% else %}
                        <span class="text-muted">n/a</span>
                      {% endif %}
                    </td>
                    <td>
                      {% if row.total_samples %}
                        {{ row.down_samples }}/{{ row.total_samples }}
                      {% else %}
                        n/a
                      {% endif %}
                    </td>
                    <td class="text-muted">
                      {% if row.speed %}
                        {{ row.speed.download_mbps if row.speed.download_mbps is not none else 'n/a' }} /
                        {{ row.speed.upload_mbps if row.speed.upload_mbps is not none else 'n/a' }} Mbps,
                        {{ row.speed.latency_ms if row.speed.latency_ms is not none else 'n/a' }} ms
                      {% else %}
                        n/a
                      {% endif %}
                    </td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        {% else %}
          <div class="text-muted">No Pulsewatch presets configured yet.</div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

<script>
  let latencySeries = {{ pulse_latency_series | tojson }};
  const chartEl = document.getElementById("pulsewatch-latency-chart");
  const legendEl = document.getElementById("pulsewatch-latency-legend");
  const filterEl = document.getElementById("pulsewatch-core-filter");
  const rangeEl = document.getElementById("pulsewatch-range-filter");
  const targetEl = document.getElementById("pulsewatch-target-filter");
  const fromEl = document.getElementById("pulsewatch-from-filter");
  const toEl = document.getElementById("pulsewatch-to-filter");

  const tooltip = document.createElement("div");
  tooltip.style.position = "absolute";
  tooltip.style.background = "#111827";
  tooltip.style.color = "#fff";
  tooltip.style.padding = "6px 8px";
  tooltip.style.borderRadius = "6px";
  tooltip.style.fontSize = "12px";
  tooltip.style.pointerEvents = "none";
  tooltip.style.display = "none";
  tooltip.style.zIndex = "10";
  chartEl.appendChild(tooltip);

  const toEpoch = (value) => {
    if (!value) return null;
    const raw = value.endsWith("Z") ? value : `${value}Z`;
    const parsed = Date.parse(raw);
    return Number.isNaN(parsed) ? null : parsed;
  };

  const toLocalEpoch = (value) => {
    if (!value) return null;
    const parsed = new Date(value).getTime();
    if (!Number.isNaN(parsed)) return parsed;
    const fallback = Date.parse(value);
    return Number.isNaN(fallback) ? null : fallback;
  };

  const resolveWindow = (series, hours, fromTs, toTs) => {
    const allTimes = series.flatMap((item) => item.points.map((point) => toEpoch(point.ts))).filter(Boolean);
    if (!allTimes.length) return null;
    const minAll = Math.min(...allTimes);
    const maxAll = Math.max(...allTimes);
    let start;
    let end;
    if (fromTs || toTs) {
      start = fromTs ?? minAll;
      end = toTs ?? maxAll;
    } else {
      end = maxAll;
      start = end - hours * 60 * 60 * 1000;
    }
    if (start > end) {
      const temp = start;
      start = end;
      end = temp;
    }
    return { start, end };
  };

  const renderChart = (coreId, hours, target, fromTs, toTs) => {
    if (!chartEl) return;
    const filtered = latencySeries.filter((item) => {
      if (coreId !== "all" && item.core_id !== coreId) return false;
      if (target !== "all" && item.target !== target) return false;
      return true;
    });
    const window = resolveWindow(filtered, hours, fromTs, toTs);
    if (!window) {
      chartEl.innerHTML = "<div class='text-muted'>No latency data available.</div>";
      return;
    }
    const series = filtered.map((item) => ({
      ...item,
      points: item.points.filter((point) => {
        const ts = toEpoch(point.ts);
        return ts !== null && ts >= window.start && ts <= window.end;
      }),
    }));
    chartEl.innerHTML = "";
    legendEl.innerHTML = "";
    chartEl.appendChild(tooltip);
    if (!series.length) {
      chartEl.innerHTML = "<div class='text-muted'>No data for selected core.</div>";
      return;
    }

    const rawPoints = series.flatMap((item) =>
      item.points.map((point) => ({ x: toEpoch(point.ts), y: point.value }))
    ).filter((point) => point.x !== null && point.y !== null);
    if (!rawPoints.length) {
      chartEl.innerHTML = "<div class='text-muted'>No latency data available.</div>";
      return;
    }

    const minX = window.start;
    const maxX = window.end;
    const renderSeries = series.map((item) => {
      const points = item.points
        .map((point) => ({ x: toEpoch(point.ts), y: point.value }))
        .filter((point) => point.x !== null && point.y !== null)
        .sort((a, b) => a.x - b.x);
      if (!points.length) return { ...item, renderPoints: [] };
      return { ...item, renderPoints: points };
    });

    const allPoints = renderSeries.flatMap((item) => item.renderPoints);
    const minY = Math.min(...allPoints.map((point) => point.y));
    const maxY = Math.max(...allPoints.map((point) => point.y));
    const width = chartEl.clientWidth || 600;
    const height = 240;
    const pad = 24;
    const spanX = Math.max(maxX - minX, 1);
    const spanY = Math.max(maxY - minY, 1);

    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", height + pad * 1.5);
    svg.setAttribute("viewBox", `0 0 ${width} ${height + pad * 1.5}`);

    const axis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    axis.setAttribute("x1", pad);
    axis.setAttribute("x2", width - pad);
    axis.setAttribute("y1", height);
    axis.setAttribute("y2", height);
    axis.setAttribute("stroke", "#e5e7eb");
    axis.setAttribute("stroke-width", "1");
    svg.appendChild(axis);

    const niceStep = (range) => {
      const rough = range / 5;
      const power = Math.pow(10, Math.floor(Math.log10(Math.max(rough, 1))));
      const scaled = rough / power;
      if (scaled <= 1) return 1 * power;
      if (scaled <= 2) return 2 * power;
      if (scaled <= 5) return 5 * power;
      return 10 * power;
    };

    const yStep = niceStep(maxY - minY);
    const yStart = Math.floor(minY / yStep) * yStep;
    const yEnd = Math.ceil(maxY / yStep) * yStep;
    for (let y = yStart; y <= yEnd; y += yStep) {
      const yPos = height - ((y - minY) / spanY) * (height - pad);
      const grid = document.createElementNS("http://www.w3.org/2000/svg", "line");
      grid.setAttribute("x1", pad);
      grid.setAttribute("x2", width - pad);
      grid.setAttribute("y1", yPos.toFixed(1));
      grid.setAttribute("y2", yPos.toFixed(1));
      grid.setAttribute("stroke", "#f3f4f6");
      grid.setAttribute("stroke-width", "1");
      svg.appendChild(grid);

      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", pad - 6);
      label.setAttribute("y", yPos + 3);
      label.setAttribute("text-anchor", "end");
      label.setAttribute("fill", "#9ca3af");
      label.setAttribute("font-size", "10");
      label.textContent = `${y}`;
      svg.appendChild(label);
    }

    const formatTimeLabel = (ts, mode) => {
      const date = new Date(ts);
      if (mode === "date") {
        return date.toLocaleDateString("en-PH", { month: "numeric", day: "numeric", year: "2-digit" });
      }
      return date.toLocaleTimeString("en-PH", { hour: "numeric", minute: "2-digit", hour12: true });
    };

    const rangeHours = Math.max((maxX - minX) / (1000 * 60 * 60), 1);
    const timeMode = rangeHours >= 24 ? "date" : "time";
    const xTicks = [];
    if (timeMode === "date") {
      const start = new Date(minX);
      start.setHours(0, 0, 0, 0);
      for (let t = start.getTime(); t <= maxX; t += 24 * 60 * 60 * 1000) {
        if (t >= minX) xTicks.push(t);
      }
      if (!xTicks.length) {
        xTicks.push(minX, maxX);
      }
    } else {
      const tickStep = rangeHours <= 6 ? 1 : 2;
      const start = new Date(minX);
      start.setMinutes(0, 0, 0);
      const startTs = start.getTime();
      for (let t = startTs; t <= maxX; t += tickStep * 60 * 60 * 1000) {
        if (t >= minX) xTicks.push(t);
      }
    }
    if (!xTicks.length) {
      xTicks.push(minX);
      if (maxX !== minX) xTicks.push(maxX);
    }
    xTicks.forEach((t) => {
      const xPos = pad + ((t - minX) / spanX) * (width - pad * 2);
      const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
      tick.setAttribute("x1", xPos.toFixed(1));
      tick.setAttribute("x2", xPos.toFixed(1));
      tick.setAttribute("y1", height);
      tick.setAttribute("y2", height + 4);
      tick.setAttribute("stroke", "#e5e7eb");
      tick.setAttribute("stroke-width", "1");
      svg.appendChild(tick);

      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", xPos.toFixed(1));
      label.setAttribute("y", height + 18);
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("fill", "#9ca3af");
      label.setAttribute("font-size", "10");
      label.textContent = formatTimeLabel(t, timeMode);
      svg.appendChild(label);
    });

    const labelX = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelX.setAttribute("x", width - pad);
    labelX.setAttribute("y", height + 24);
    labelX.setAttribute("text-anchor", "end");
    labelX.setAttribute("fill", "#9ca3af");
    labelX.setAttribute("font-size", "10");
    labelX.textContent = "Time (PHT)";
    svg.appendChild(labelX);

    const labelY = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelY.setAttribute("x", pad);
    labelY.setAttribute("y", 12);
    labelY.setAttribute("text-anchor", "start");
    labelY.setAttribute("fill", "#9ca3af");
    labelY.setAttribute("font-size", "10");
    labelY.textContent = "Latency (ms)";
    svg.appendChild(labelY);

    renderSeries.forEach((item) => {
      if (!item.renderPoints.length) return;
      const sorted = item.renderPoints.slice().sort((a, b) => a.x - b.x);
      const gapThresholdMs = 2 * 60 * 1000;
      let segment = [];
      const flushSegment = () => {
        if (segment.length < 2) {
          segment = [];
          return;
        }
        const path = segment
          .map((point) => {
            const x = pad + ((point.x - minX) / spanX) * (width - pad * 2);
            const y = height - ((point.y - minY) / spanY) * (height - pad);
            return `${x.toFixed(1)},${y.toFixed(1)}`;
          })
          .join(" ");
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("points", path);
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", item.color);
        polyline.setAttribute("stroke-width", "2");
        polyline.setAttribute("opacity", "0.9");
        polyline.setAttribute("data-series-id", item.id);
        svg.appendChild(polyline);
        segment = [];
      };
      let lastPoint = null;
      sorted.forEach((point) => {
        if (lastPoint && point.x - lastPoint.x > gapThresholdMs) {
          flushSegment();
        }
        segment.push(point);
        lastPoint = point;
      });
      flushSegment();

      const legend = document.createElement("div");
      legend.className = "d-flex align-items-center gap-2";
      legend.setAttribute("data-series-id", item.id);
      legend.innerHTML = `<span style="width:12px;height:12px;border-radius:50%;background:${item.color};display:inline-block;"></span><span class="small text-muted">${item.name}</span>`;
      legendEl.appendChild(legend);
    });

    const overlay = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    overlay.setAttribute("x", pad);
    overlay.setAttribute("y", 0);
    overlay.setAttribute("width", width - pad * 2);
    overlay.setAttribute("height", height);
    overlay.setAttribute("fill", "transparent");
    overlay.style.cursor = "default";
    svg.appendChild(overlay);

    overlay.addEventListener("mousemove", (event) => {
      const rect = svg.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const rel = Math.min(Math.max(x - pad, 0), width - pad * 2);
      const targetTs = minX + (rel / (width - pad * 2)) * spanX;
      const details = [];
      const activeList = activeIds.size ? Array.from(activeIds) : null;
      series.forEach((item) => {
        if (activeList && !activeIds.has(item.id)) {
          return;
        }
        const points = item.points
          .map((point) => ({ x: toEpoch(point.ts), y: point.value }))
          .filter((point) => point.x !== null && point.y !== null);
        if (!points.length) return;
        let nearest = points[0];
        let best = Math.abs(points[0].x - targetTs);
        for (const point of points) {
          const diff = Math.abs(point.x - targetTs);
          if (diff < best) {
            best = diff;
            nearest = point;
          }
        }
        details.push({ name: item.name, color: item.color, value: nearest.y });
      });
      const timeLabel = new Date(targetTs).toLocaleString("en-PH", { hour12: true });
      tooltip.innerHTML = `<div class="fw-semibold mb-1">${timeLabel}</div>` +
        details.map((item) => `<div style="display:flex;gap:6px;align-items:center;"><span style="width:8px;height:8px;border-radius:50%;background:${item.color};display:inline-block;"></span><span>${item.name}: ${item.value.toFixed(1)} ms</span></div>`).join("");
      tooltip.style.left = `${Math.min(x + 12, rect.width - 220)}px`;
      tooltip.style.top = `${Math.max(8, event.clientY - rect.top - 60)}px`;
      tooltip.style.display = "block";
    });

    overlay.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });

    overlay.addEventListener("wheel", (event) => {
      if (!event.ctrlKey) return;
      event.preventDefault();
      const rect = svg.getBoundingClientRect();
      const x = Math.min(Math.max(event.clientX - rect.left, pad), width - pad);
      const rel = Math.min(Math.max(x - pad, 0), width - pad * 2);
      const anchorTs = minX + (rel / (width - pad * 2)) * spanX;
      const { fromTs, toTs } = syncRangeState();
      const window = resolveZoomWindow(getRangeHours(), fromTs, toTs);
      const currentStart = window.start;
      const currentEnd = window.end;
      const scale = event.deltaY < 0 ? 0.8 : 1.25;
      const newStart = anchorTs - (anchorTs - currentStart) * scale;
      const newEnd = anchorTs + (currentEnd - anchorTs) * scale;
      setWindow(newStart, newEnd);
      updateChart();
    }, { passive: false });

    chartEl.appendChild(svg);

    const activeIds = new Set();
    const setOpacity = () => {
      const lines = svg.querySelectorAll("polyline[data-series-id]");
      const hasSelection = activeIds.size > 0;
      lines.forEach((line) => {
        const id = line.getAttribute("data-series-id");
        line.setAttribute("opacity", hasSelection && !activeIds.has(id) ? "0.2" : "0.95");
      });
      const labels = legendEl.querySelectorAll("[data-series-id]");
      labels.forEach((label) => {
        const id = label.getAttribute("data-series-id");
        label.style.opacity = hasSelection && !activeIds.has(id) ? "0.4" : "1";
        label.style.fontWeight = activeIds.has(id) ? "600" : "400";
      });
    };

    legendEl.querySelectorAll("[data-series-id]").forEach((label) => {
      const seriesId = label.getAttribute("data-series-id");
      label.style.cursor = "pointer";
      label.addEventListener("click", () => {
        if (activeIds.has(seriesId)) {
          activeIds.delete(seriesId);
        } else {
          activeIds.add(seriesId);
        }
        setOpacity();
      });
    });
  };

  const getRangeHours = () => {
    const parsed = parseInt(rangeEl.value, 10);
    return Number.isNaN(parsed) ? 24 : parsed;
  };

  const formatLocalInput = (ts) => {
    const dt = new Date(ts);
    if (Number.isNaN(dt.getTime())) return "";
    const pad = (n) => String(n).padStart(2, "0");
    const yyyy = dt.getFullYear();
    const mm = pad(dt.getMonth() + 1);
    const dd = pad(dt.getDate());
    const hh = pad(dt.getHours());
    const min = pad(dt.getMinutes());
    return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
  };

  const resolveZoomWindow = (hours, fromTs, toTs) => {
    let start;
    let end;
    if (fromTs || toTs) {
      start = fromTs ?? toTs;
      end = toTs ?? fromTs;
    } else {
      end = Date.now();
      start = end - hours * 60 * 60 * 1000;
    }
    if (start > end) {
      const temp = start;
      start = end;
      end = temp;
    }
    return { start, end };
  };

  const toIsoString = (value) => {
    if (!value) return null;
    const dt = new Date(value);
    if (Number.isNaN(dt.getTime())) return null;
    return dt.toISOString();
  };

  const syncRangeState = () => {
    const fromTs = toLocalEpoch(fromEl.value);
    const toTs = toLocalEpoch(toEl.value);
    const hasWindow = Boolean(fromTs || toTs);
    rangeEl.disabled = hasWindow;
    return { fromTs, toTs };
  };

  const fetchSeries = async (hours, fromIso, toIso) => {
    const params = new URLSearchParams();
    params.set("core_id", filterEl.value);
    params.set("target", targetEl.value);
    params.set("hours", String(hours));
    if (fromIso) params.set("start", fromIso);
    if (toIso) params.set("end", toIso);
    const response = await fetch(`/pulsewatch/latency-series?${params.toString()}`, {
      headers: { "Accept": "application/json" },
    });
    if (!response.ok) {
      throw new Error("Failed to load latency series");
    }
    const payload = await response.json();
    latencySeries = payload.series || [];
  };

  const updateChart = async () => {
    const { fromTs, toTs } = syncRangeState();
    const hours = getRangeHours();
    const fromIso = toIsoString(fromEl.value);
    const toIso = toIsoString(toEl.value);
    try {
      await fetchSeries(hours, fromIso, toIso);
    } catch (err) {
      console.error(err);
    }
    renderChart(filterEl.value, hours, targetEl.value, fromTs, toTs);
  };

  if (filterEl) {
    filterEl.addEventListener("change", () => {
      updateChart();
    });
  }
  if (rangeEl) {
    rangeEl.addEventListener("change", () => {
      if (fromEl) fromEl.value = "";
      if (toEl) toEl.value = "";
      rangeEl.disabled = false;
      updateChart();
    });
  }
  if (targetEl) {
    targetEl.addEventListener("change", () => {
      updateChart();
    });
  }
  if (fromEl) {
    fromEl.addEventListener("change", () => {
      updateChart();
    });
  }
  if (toEl) {
    toEl.addEventListener("change", () => {
      updateChart();
    });
  }
  const setWindow = (start, end) => {
    fromEl.value = formatLocalInput(start);
    toEl.value = formatLocalInput(end);
  };


  window.addEventListener("resize", () => {
    const { fromTs, toTs } = syncRangeState();
    renderChart(filterEl ? filterEl.value : "all", getRangeHours(), targetEl.value, fromTs, toTs);
  });

  updateChart();
</script>
<script>
  const stabilityGridEl = document.getElementById("pulsewatch-stability-grid");
  const stabilityDaysEl = document.getElementById("pulsewatch-stability-days");
  const stabilityColors = ["#2fb344", "#f59f00", "#e03131", "#f76707"];
  const stabilityCharts = new Map();

  const escapeHtml = (value) => String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#39;");

  const renderStabilityGrid = (rows) => {
    if (!stabilityGridEl) return;
    stabilityCharts.forEach((chart) => chart.destroy());
    stabilityCharts.clear();
    if (!rows.length) {
      stabilityGridEl.innerHTML = "<div class='text-muted'>No Pulsewatch presets with IPs.</div>";
      return;
    }
    stabilityGridEl.innerHTML = rows.map((row) => {
      const chartId = `pulsewatch-stability-${row.id}`;
      return `
        <div class="pulsewatch-stability-item">
          <div class="pulsewatch-stability-chart-wrap">
            <div id="${chartId}" class="pulsewatch-stability-chart"></div>
            <div class="pulsewatch-stability-label">${escapeHtml(row.label || "Unnamed ISP")}</div>
          </div>
        </div>
      `;
    }).join("");

    rows.forEach((row) => {
      const chartId = `pulsewatch-stability-${row.id}`;
      const el = document.getElementById(chartId);
      if (!el || !window.ApexCharts) return;
      const series = [row.healthy || 0, row.degraded || 0, row.poor || 0, row.outage || 0];
      const total = series.reduce((sum, value) => sum + value, 0);
      if (!total) {
        el.innerHTML = "<div class='text-muted'>No data in range.</div>";
        return;
      }
      const rangeLabel = (stabilityDaysEl ? stabilityDaysEl.selectedOptions[0]?.textContent : "Last 7 days") || "Last 7 days";
      const fullLabel = row.full_label || row.label || "Unnamed ISP";
      const chart = new ApexCharts(el, {
        chart: {
          type: "donut",
          height: 90,
          sparkline: { enabled: true },
        },
        labels: ["Stable", "Unstable", "Critical", "Down"],
        colors: stabilityColors,
        series,
        dataLabels: { enabled: false },
        legend: { show: false },
        stroke: { width: 1 },
        tooltip: {
          enabled: true,
          custom: ({ series, seriesIndex, w }) => {
            const legendRows = w.globals.labels.map((label, idx) => {
              const value = series[idx] || 0;
              const percent = total ? Math.round((value / total) * 100) : 0;
              const color = stabilityColors[idx];
              return `<div class="d-flex align-items-center gap-2">
                <span style="width:8px;height:8px;border-radius:50%;background:${color};display:inline-block;"></span>
                <span>${label} ${percent}%</span>
              </div>`;
            }).join("");
            return `
              <div class="apexcharts-tooltip-title small text-muted ms-1">${rangeLabel}</div>
              <div class="fw-semibold mb-2 ms-1">${escapeHtml(fullLabel)}</div>
              <div class="d-flex flex-column gap-1 small ms-1">${legendRows}</div>
            `;
          },
        },
        plotOptions: {
          pie: {
            donut: {
              size: "70%",
              labels: { show: false },
            },
          },
        },
      });
      chart.render();
      stabilityCharts.set(row.id, chart);
    });
  };

  const fetchStability = async () => {
    if (!stabilityGridEl) return;
    const window = (() => {
      const raw = stabilityDaysEl ? stabilityDaysEl.value : "7d";
      if (raw.endsWith("h")) {
        const hours = parseInt(raw.slice(0, -1), 10);
        return { hours: Number.isNaN(hours) ? 1 : hours };
      }
      if (raw.endsWith("d")) {
        const days = parseInt(raw.slice(0, -1), 10);
        return { days: Number.isNaN(days) ? 7 : days };
      }
      const days = parseInt(raw, 10);
      return { days: Number.isNaN(days) ? 7 : days };
    })();
    const params = new URLSearchParams();
    if (window.hours) {
      params.set("hours", String(window.hours));
    } else {
      params.set("days", String(window.days || 7));
    }
    try {
      const res = await fetch(`/pulsewatch/stability?${params.toString()}`, {
        headers: { "Accept": "application/json" },
      });
      if (!res.ok) {
        throw new Error("Failed to load stability data");
      }
      const data = await res.json();
      renderStabilityGrid(data.rows || []);
    } catch (err) {
      stabilityGridEl.innerHTML = "<div class='text-muted'>Unable to load stability overview.</div>";
    }
  };

  if (stabilityDaysEl) {
    stabilityDaysEl.addEventListener("change", fetchStability);
  }
  fetchStability();
</script>
<script>
  const summaryTargetEl = document.getElementById("pulsewatch-summary-target");
  const summaryBodyEl = document.getElementById("pulsewatch-summary-body");
  const summaryTotalEl = document.getElementById("pulsewatch-summary-total");
  const summaryLastEl = document.getElementById("pulsewatch-summary-last");
  const summaryRefresh = summaryBodyEl ? parseInt(summaryBodyEl.dataset.refresh || "2", 10) : 2;
  const summaryLossMinutes = summaryBodyEl ? parseInt(summaryBodyEl.dataset.lossMinutes || "120", 10) : 120;

  const renderLossSparkline = (points) => {
    if (!points) return "<span class='text-muted'>n/a</span>";
    return `<svg width=\"120\" height=\"30\" viewBox=\"0 0 120 30\"><polyline points=\"${points}\" fill=\"none\" stroke=\"#2fb344\" stroke-width=\"2\" /></svg>`;
  };

  const renderSummaryRows = (rows) => {
    if (!summaryBodyEl) return;
    summaryBodyEl.innerHTML = rows.map((row) => {
      const speed = row.speed || {};
      const lossMax = row.loss_max === null || row.loss_max === undefined ? "n/a" : `${row.loss_max}%`;
      const avgMax = row.avg_max === null || row.avg_max === undefined ? "n/a" : `${row.avg_max}ms`;
      const speedText = speed.download_mbps !== undefined && speed.download_mbps !== null
        ? `${speed.download_mbps} / ${speed.upload_mbps ?? "n/a"} Mbps, ${speed.latency_ms ?? "n/a"} ms`
        : "n/a";
      const downtime = row.total_samples ? `${row.down_samples}/${row.total_samples}` : "n/a";
      return `
        <tr>
          <td class="fw-semibold">${row.label}</td>
          <td>${row.source_ip || "n/a"}</td>
          <td>${row.last_check || "n/a"}</td>
          <td>${lossMax}</td>
          <td>${avgMax}</td>
          <td>${renderLossSparkline(row.loss_points)}</td>
          <td>${downtime}</td>
          <td class="text-muted">${speedText}</td>
        </tr>
      `;
    }).join("");
  };

  const fetchSummary = async () => {
    if (!summaryBodyEl) return;
    const target = summaryTargetEl ? summaryTargetEl.value : "all";
    const params = new URLSearchParams({
      target,
      loss_minutes: String(summaryLossMinutes),
    });
    try {
      const res = await fetch(`/pulsewatch/summary?${params.toString()}`, { headers: { "Accept": "application/json" } });
      if (!res.ok) return;
      const data = await res.json();
      if (summaryTotalEl) summaryTotalEl.textContent = data.total ?? "0";
      if (summaryLastEl) summaryLastEl.textContent = data.last_check || "n/a";
      renderSummaryRows(data.rows || []);
    } catch (err) {
      // ignore
    }
  };

  if (summaryTargetEl) {
    summaryTargetEl.addEventListener("change", fetchSummary);
  }
  fetchSummary();
  setInterval(fetchSummary, Math.max(summaryRefresh, 2) * 1000);
</script>
{% endblock %}
