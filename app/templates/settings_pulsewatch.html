{% extends "base.html" %}
{% block title %}ISP Pulsewatch{% endblock %}
{% block header_title %}ISP Pulsewatch{% endblock %}
{% block header_badge %}
  <span class="badge bg-green-lt text-green header-icon-badge"><i class="ti ti-activity"></i></span>
{% endblock %}
{% block content %}
<div class="card">
  <div class="card-body">
  {% if message %}
    <div class="alert alert-info">{{ message }}</div>
    <div id="pulsewatch_modal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: flex; align-items: center; justify-content: center; z-index: 1000;">
      <div style="background: #fffdf4; border: 1px solid #d6d6cf; padding: 18px; border-radius: 10px; min-width: 320px; max-width: 720px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <strong>Pulsewatch Result</strong>
          <button type="button" id="pulsewatch_modal_close" style="border: none; background: transparent; font-size: 18px; cursor: pointer;">&times;</button>
        </div>
        <div style="margin-top: 10px; white-space: pre-wrap;">{{ message }}</div>
        <div style="margin-top: 14px; text-align: right;">
          <button type="button" class="btn btn-primary" id="pulsewatch_modal_ok">OK</button>
        </div>
      </div>
    </div>
  {% endif %}

  <ul class="nav nav-tabs" data-bs-toggle="tabs" id="pulsewatch-tabs">
    <li class="nav-item">
      <a href="#pulsewatch-status" class="nav-link active" data-bs-toggle="tab">Status</a>
    </li>
    <li class="nav-item">
      <a href="#pulsewatch-presets" class="nav-link" data-bs-toggle="tab">Pulsewatch Presets</a>
    </li>
    <li class="nav-item">
      <a href="#pulsewatch-settings" class="nav-link" data-bs-toggle="tab">Settings</a>
    </li>
  </ul>
  <div class="tab-content pt-4">
    <div class="tab-pane active" id="pulsewatch-status">
      <div class="d-flex flex-wrap align-items-center justify-content-between mb-3 gap-2">
        <div>
          <h4 class="mb-1">
            Pulsewatch Status
            {% if pulse_enabled %}
              <span class="badge bg-green-lt ms-1">Active</span>
            {% else %}
              <span class="badge bg-gray-lt ms-1">Paused</span>
            {% endif %}
          </h4>
          <div class="text-muted small">Last check: {{ pulse_last_check or 'n/a' }} · Last reconcile: {{ pulse_last_reconcile or 'n/a' }}</div>
        </div>
        <div class="d-flex flex-wrap gap-2 align-items-center">
          <span class="badge bg-blue-lt">ISPs: {{ pulse_total }}</span>
          <span class="badge bg-azure-lt">Reachability: {{ pulsewatch_reachability_checked_at or 'n/a' }}</span>
        </div>
      </div>

      <div class="row row-cards">
        <div class="col-12">
          <div class="card">
            <div class="card-header">
              <div class="row g-2 align-items-center w-100">
                <div class="col-12 col-lg-6">
                  <h3 class="card-title mb-0">Pulsewatch Latency Trend</h3>
                  <div class="text-muted small">Latency vs time (PHT)</div>
                </div>
                <div class="col-12 col-lg-6">
                  <div class="d-flex align-items-center gap-2 flex-nowrap justify-content-lg-end flex-wrap">
                    <span class="text-muted small">Core</span>
                    <select class="form-select form-select-sm" id="pulsewatch-core-filter" style="min-width: 160px;">
                      <option value="all">All cores</option>
                      {% for core in settings.pulsewatch.mikrotik.cores %}
                        <option value="{{ core.id }}">{{ core.label }}</option>
                      {% endfor %}
                    </select>
                    <span class="text-muted small">Range</span>
                    <select class="form-select form-select-sm" id="pulsewatch-range-filter" style="min-width: 120px;">
                      <option value="6">Last 6h</option>
                      <option value="12">Last 12h</option>
                      <option value="24" selected>Last 24h</option>
                    </select>
                    <span class="text-muted small">Target</span>
                    <select class="form-select form-select-sm" id="pulsewatch-target-filter" style="min-width: 140px;">
                      <option value="all">All targets</option>
                      {% for target in pulse_targets %}
                        <option value="{{ target }}">{{ target }}</option>
                      {% endfor %}
                    </select>
                    <span class="text-muted small">From</span>
                    <input class="form-control form-control-sm" id="pulsewatch-from-filter" type="datetime-local" style="min-width: 190px;">
                    <span class="text-muted small">To</span>
                    <input class="form-control form-control-sm" id="pulsewatch-to-filter" type="datetime-local" style="min-width: 190px;">
                  </div>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div id="pulsewatch-latency-chart" style="width: 100%; height: 260px; position: relative;"></div>
              <div id="pulsewatch-latency-legend" class="mt-3 d-flex flex-wrap gap-3"></div>
            </div>
          </div>
        </div>
      </div>

        <div class="row row-cards mt-3">
          <div class="col-12">
            <div class="card">
              <div class="card-header">
                <div class="row g-2 align-items-center w-100">
                  <div class="col-12 col-lg">
                    <h3 class="card-title mb-0">Pulsewatch ISP Summary</h3>
                    <div class="text-muted small">Loss window: last {{ pulse_summary_loss_minutes }} minutes</div>
                  </div>
	                  <div class="col-12 col-lg-auto">
	                    <div class="d-flex align-items-center gap-2 flex-wrap justify-content-lg-end">
	                      <span class="badge bg-blue-lt d-inline-flex align-items-center text-nowrap">
	                        <i class="ti ti-list-numbers me-1"></i>
	                        Total: <span id="pulsewatch-summary-total">{{ pulse_total }}</span>
	                      </span>
	                      <span class="badge bg-azure-lt d-inline-flex align-items-center text-nowrap">
	                        <i class="ti ti-clock me-1"></i>
	                        Last: <span id="pulsewatch-summary-last">{{ pulse_last_check or 'n/a' }}</span>
	                      </span>
	                      <select class="form-select form-select-sm" id="pulsewatch-summary-target" style="min-width: 140px;">
	                        <option value="all" {% if pulse_summary_target == "all" %}selected{% endif %}>All targets</option>
	                        {% for target in pulse_targets %}
	                          <option value="{{ target }}" {% if pulse_summary_target == target %}selected{% endif %}>{{ target }}</option>
	                        {% endfor %}
	                      </select>
	                    </div>
	                  </div>
                </div>
              </div>
              <div class="card-body">
                {% if pulse_rows %}
                  <div class="table-responsive">
                    <table class="table table-vcenter">
                      <thead>
                        <tr>
                          <th>ISP</th>
                          <th>Source IP</th>
                          <th>Last Check</th>
                          <th>Loss Max</th>
                          <th>Avg Max</th>
                          <th>Loss History</th>
                          <th>Downtime</th>
                          <th>Last Speedtest</th>
                        </tr>
                      </thead>
                      <tbody id="pulsewatch-summary-body" data-loss-minutes="{{ pulse_summary_loss_minutes }}" data-refresh="{{ pulse_summary_refresh }}" data-range-label="Last {{ pulse_summary_loss_minutes }} minutes">
                        {% for row in pulse_rows %}
                          <tr>
                            <td class="fw-semibold">{{ row.label }}</td>
                            <td>{{ row.source_ip or 'n/a' }}</td>
                            <td>{{ row.last_check or 'n/a' }}</td>
                            <td>{{ row.loss_max if row.loss_max is not none else 'n/a' }}%</td>
                            <td>{{ row.avg_max if row.avg_max is not none else 'n/a' }}ms</td>
	                          <td>
	                            {% if row.loss_points %}
	                              <button type="button" class="btn btn-link p-0 pulsewatch-spark-btn"
	                                      data-bs-toggle="modal"
	                                      data-bs-target="#pulsewatch-spark-modal"
	                                      data-row-id="{{ row.row_id|e }}"
	                                      data-label="{{ row.label|e }}"
	                                      data-points="{{ row.loss_points|default('')|e }}"
	                                      data-points-large="{{ row.loss_points_large|default('')|e }}"
	                                      data-color="{{ (row.color or '#2fb344')|e }}">
	                                <svg width="120" height="30" viewBox="0 0 120 30">
                                    <polyline points="{{ row.loss_points }}" fill="none" stroke="#2fb344" stroke-width="2" />
                                  </svg>
                                </button>
                              {% else %}
                                <span class="text-muted">n/a</span>
                              {% endif %}
                            </td>
                            <td>
                              {% if row.total_samples %}
                                {{ row.down_samples }}/{{ row.total_samples }}
                              {% else %}
                                n/a
                              {% endif %}
                            </td>
                            <td class="text-muted">
                              {% if row.speed %}
                                {{ row.speed.download_mbps if row.speed.download_mbps is not none else 'n/a' }} /
                                {{ row.speed.upload_mbps if row.speed.upload_mbps is not none else 'n/a' }} Mbps,
                                {{ row.speed.latency_ms if row.speed.latency_ms is not none else 'n/a' }} ms
                              {% else %}
                                n/a
                              {% endif %}
                            </td>
                          </tr>
                        {% endfor %}
                      </tbody>
                    </table>
                  </div>
                {% else %}
                  <div class="text-muted">No Pulsewatch presets configured yet.</div>
                {% endif %}
              </div>
            </div>
          </div>
        </div>
    </div>
    <div class="tab-pane" id="pulsewatch-presets">
      <form method="post">
        <div class="card">
          <div class="card-body">
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
              <h4 class="mb-0">Pulsewatch Presets</h4>
              <div class="d-flex gap-2 flex-wrap">
                <button type="submit" class="btn" formaction="/settings/pulsewatch/test" formmethod="post">Send Test Telegram</button>
                <button type="button" class="btn btn-primary" id="pulsewatch_ping_all">Run Ping All</button>
                <button type="button" class="btn btn-outline-primary" id="pulsewatch_speedtest_all">Run Speedtest All</button>
                <button type="button" class="btn btn-warning" id="pulsewatch_reachability_fix" data-bs-toggle="modal" data-bs-target="#pulsewatch-reachability-modal">Fix Reachability</button>
              </div>
            </div>
            <div class="text-muted small mt-1">
              Reachability checks run every 10 minutes using the first target for each preset.
              <span id="pulsewatch_reachability_last">Last check: {{ pulsewatch_reachability_checked_at or 'n/a' }}</span>
            </div>

            <div class="alert alert-info mt-3 mb-3">
              <div class="d-flex align-items-start">
                <span class="me-2"><i class="ti ti-info-circle"></i></span>
                <div>
                  Lists are loaded from each MikroTik. Fill in the IP address for the list entry you want added.
                  Saving presets updates the host IP assignments (netplan) and can sync MikroTik address-lists if enabled.
                </div>
              </div>
            </div>

            {% set cores = settings.pulsewatch.mikrotik.cores %}
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-3">
              <input class="form-control" type="text" id="pulsewatch_search" placeholder="Search list..." style="min-width: 220px;" />
            </div>
            {% if show_preset_recommendation %}
            <div id="pulsewatch_recommendation_alert" class="alert alert-warning mb-3 position-relative">
              <button type="button" class="btn-close position-absolute top-0 end-0 mt-2 me-2" aria-label="Close" id="pulsewatch_recommendation_close"></button>
              <div class="d-flex align-items-start">
                <span class="me-2"><i class="ti ti-alert-triangle"></i></span>
                <div class="flex-grow-1">
                  <strong>Recommended IPs suggested.</strong>
                  <div class="small text-muted">Based on each core gateway, the system suggested sequential IPs for these lists. You can apply or remove them before saving.</div>
                </div>
              </div>
              <div class="d-flex justify-content-end gap-2 mt-3">
                <button type="button" class="btn btn-sm btn-outline-secondary" id="pulsewatch_recommendation_clear">Remove recommendation</button>
                <button type="button" class="btn btn-sm btn-warning" id="pulsewatch_recommendation_apply">Apply</button>
              </div>
            </div>
            {% endif %}

            <input type="hidden" name="preset_count" value="{{ preset_rows|length }}" />
            <div style="overflow-x: auto;">
              <table id="pulsewatch_table" class="table table-vcenter" style="width: 100%;">
            <thead>
              <tr>
                <th data-sort="text" title="Which MikroTik router this preset belongs to." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">MikroTik</th>
                <th data-sort="text" title="Address-list name pulled from the MikroTik firewall." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">List</th>
                <th data-sort="text" title="Friendly identifier for this ISP/list." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Identifier</th>
                <th data-sort="text" title="Custom color for this ISP line on the dashboard." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Color</th>
                <th data-sort="text" title="Source IP to bind for this list (used by ping/speedtest)." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">IP Address</th>
                <th data-sort="text" title="Reachability of the source IP to its first ping target." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Reachability</th>
                <th data-sort="number" title="Latency threshold (ms) before a breach is counted." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Latency</th>
                <th data-sort="number" title="Packet loss threshold (%) before a breach is counted." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Loss</th>
                <th data-sort="number" title="How many consecutive breaches trigger an alert." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Breaches</th>
                <th data-sort="number" title="Cooldown minutes after an alert to avoid repeats." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Cooldown</th>
                <th data-sort="text" title="Ping targets (one per line) to test for this list." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf; cursor: pointer;">Targets</th>
                <th title="Run ping/speedtest actions for this preset." style="text-align: left; padding: 8px; border-bottom: 1px solid #d6d6cf;">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for row in preset_rows %}
                <tr class="pulsewatch-row" data-row-id="{{ row.row_id }}">
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    {{ row.core_label }}
                    <input type="hidden" name="preset_{{ loop.index0 }}_core_id" value="{{ row.core_id }}" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    {{ row.list_name }}
                    <input type="hidden" name="preset_{{ loop.index0 }}_list" value="{{ row.list_name }}" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="text" name="preset_{{ loop.index0 }}_identifier" value="{{ row.identifier }}" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="color" name="preset_{{ loop.index0 }}_color" value="{{ row.color or '#1f77b4' }}" title="Pick chart color" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="text" name="preset_{{ loop.index0 }}_address" value="{{ row.address or row.recommended_address }}" {% if row.recommended_address %}data-recommended="1"{% endif %} />
                  </td>
                  <td class="pulsewatch-reach-cell" data-row-id="{{ row.row_id }}" style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    {% set reach = row.reachability %}
                    {% if reach.status == 'reachable' %}
                      <span class="badge bg-green-lt">Reachable</span>
                    {% elif reach.status == 'unreachable' %}
                      <span class="badge bg-red-lt">Unreachable</span>
                    {% elif reach.status == 'missing' %}
                      <span class="badge bg-gray-lt">Missing</span>
                    {% else %}
                      <span class="badge bg-yellow-lt">Unknown</span>
                    {% endif %}
                    <div class="text-muted small mt-1">
                      {{ reach.last_check or 'n/a' }}
                    </div>
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="number" name="preset_{{ loop.index0 }}_latency_ms" value="{{ row.latency_ms }}" style="max-width: 90px;" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="number" name="preset_{{ loop.index0 }}_loss_pct" value="{{ row.loss_pct }}" style="max-width: 70px;" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="number" name="preset_{{ loop.index0 }}_breach_count" value="{{ row.breach_count }}" style="max-width: 70px;" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <input type="number" name="preset_{{ loop.index0 }}_cooldown_minutes" value="{{ row.cooldown_minutes }}" style="max-width: 80px;" />
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7;">
                    <textarea name="preset_{{ loop.index0 }}_ping_targets" style="min-width: 160px; min-height: 60px;">{% for target in row.ping_targets %}{{ target }}
{% endfor %}</textarea>
                  </td>
                  <td style="padding: 8px; border-bottom: 1px solid #efefe7; white-space: nowrap;">
                    <button type="button" class="btn btn-primary pulsewatch-ping" title="Run Ping" data-row-id="{{ row.row_id }}">P</button>
                    <button type="button" class="btn btn-outline-primary pulsewatch-speedtest" title="Run Speedtest" data-row-id="{{ row.row_id }}">S</button>
                  </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
            </div>
          </div>
          <div class="card-footer d-flex justify-content-end">
            <button type="submit" class="btn btn-primary">Save ISP Pulsewatch Settings</button>
          </div>
        </div>
      </form>
    </div>
    <div class="tab-pane" id="pulsewatch-settings">
      <form method="post">
        <ul class="nav nav-tabs" data-bs-toggle="tabs">
          <li class="nav-item">
            <a href="#pulsewatch-core" class="nav-link active" data-bs-toggle="tab">Core</a>
          </li>
          <li class="nav-item">
            <a href="#pulsewatch-monitoring" class="nav-link" data-bs-toggle="tab">Monitoring & Alerts</a>
          </li>
          <li class="nav-item">
            <a href="#pulsewatch-dashboard" class="nav-link" data-bs-toggle="tab">Dashboard</a>
          </li>
          <li class="nav-item">
            <a href="#pulsewatch-danger" class="nav-link" data-bs-toggle="tab">Danger</a>
          </li>
        </ul>

        <div class="tab-content pt-4">
          <div class="tab-pane active" id="pulsewatch-core">
            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-3">Pulsewatch Core Settings</h4>
                <div class="mb-3">
                  <label class="form-label">Enable ISP Pulsewatch <span class="info" data-tip="Turns on continuous Pulsewatch ping monitoring.">i</span></label>
                  <label class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" name="pulsewatch_enabled" id="pulsewatch_enabled" {% if settings.pulsewatch.enabled %}checked{% endif %} />
                    <span class="form-check-label">Active</span>
                  </label>
                </div>

                <div class="form-grid">
                  <div>
                    <label>Auto-manage MikroTik address-lists <span class="info" data-tip="Keeps TO-ISP# address-lists in sync for Pulsewatch source IPs.">i</span></label>
                    <label class="form-check form-switch">
                      <input class="form-check-input" type="checkbox" name="pulsewatch_manage_address_lists" {% if settings.pulsewatch.manage_address_lists %}checked{% endif %} />
                      <span class="form-check-label">Enabled</span>
                    </label>
                  </div>
                  <div>
                    <label>Reconcile Interval (minutes) <span class="info" data-tip="How often to reconcile MikroTik address-lists.">i</span></label>
                    <input type="number" name="pulsewatch_reconcile_interval_minutes" value="{{ settings.pulsewatch.reconcile_interval_minutes }}" />
                  </div>
                  <div>
                    <label>Store raw output <span class="info" data-tip="Persist raw ping/speedtest output in the database.">i</span></label>
                    <label class="form-check form-switch">
                      <input class="form-check-input" type="checkbox" name="pulsewatch_store_raw_output" {% if settings.pulsewatch.store_raw_output %}checked{% endif %} />
                      <span class="form-check-label">Enabled</span>
                    </label>
                  </div>
                  <div>
                    <label>Raw Data Retention Days <span class="info" data-tip="Auto-delete raw Pulsewatch results older than this many days.">i</span></label>
                    <input type="number" name="pulsewatch_retention_days" value="{{ settings.pulsewatch.retention_days }}" />
                  </div>
                  <div>
                    <label>Rollup Retention Days <span class="info" data-tip="Keeps aggregated latency rollups for long-term charts (spike-aware).">i</span></label>
                    <input type="number" name="pulsewatch_rollup_retention_days" value="{{ settings.pulsewatch.rollup_retention_days }}" />
                  </div>
                </div>
                <div class="alert alert-info mt-3">
                  <div class="d-flex align-items-center">
                    <span class="me-2"><i class="ti ti-info-circle"></i></span>
                    <div>MikroTik API credentials are managed under System Settings.</div>
                  </div>
                </div>
              </div>
              <div class="card-footer d-flex justify-content-end">
                <button type="submit" class="btn btn-primary">Save Core Settings</button>
              </div>
            </div>
          </div>

          <div class="tab-pane" id="pulsewatch-monitoring">
            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-3">Ping</h4>
                <div class="form-grid">
                  <div>
                    <label>Ping Timeout (seconds) <span class="info" data-tip="Timeout per ping attempt for Pulsewatch checks.">i</span></label>
                    <input type="number" name="pulsewatch_ping_timeout_seconds" value="{{ settings.pulsewatch.ping.timeout_seconds }}" />
                  </div>
                  <div>
                    <label>Ping Count <span class="info" data-tip="How many ICMP packets to send per target per check.">i</span></label>
                    <input type="number" name="pulsewatch_ping_count" value="{{ settings.pulsewatch.ping.count }}" />
                  </div>
                  <div>
                    <label>Ping Interval (seconds) <span class="info" data-tip="How often Pulsewatch runs the ping cycle while enabled.">i</span></label>
                    <input type="number" name="pulsewatch_ping_interval_seconds" value="{{ settings.pulsewatch.ping.interval_seconds }}" />
                  </div>
                  <div>
                    <label>Max Parallel Pings <span class="info" data-tip="Limit concurrent ping tasks to reduce CPU load.">i</span></label>
                    <input type="number" name="pulsewatch_ping_max_parallel" value="{{ settings.pulsewatch.ping.max_parallel }}" />
                  </div>
                </div>
              </div>
            </div>

            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-3">Speedtest</h4>
                <div class="form-grid">
                  <div>
                    <label>Enable Speedtest <span class="info" data-tip="Allow manual or scheduled speedtests per ISP.">i</span></label>
                    <label class="form-check form-switch">
                      <input class="form-check-input" type="checkbox" name="speedtest_enabled" {% if settings.pulsewatch.speedtest.enabled %}checked{% endif %} />
                      <span class="form-check-label">Enabled</span>
                    </label>
                  </div>
                  <div>
                    <label>Min Interval (minutes) <span class="info" data-tip="Minimum minutes between speedtests per ISP.">i</span></label>
                    <input type="number" name="speedtest_min_interval_minutes" value="{{ settings.pulsewatch.speedtest.min_interval_minutes }}" />
                  </div>
                  <div>
                    <label>Command <span class="info" data-tip="Speedtest CLI command (e.g., speedtest).">i</span></label>
                    <input type="text" name="speedtest_command" value="{{ settings.pulsewatch.speedtest.command }}" />
                  </div>
                  <div>
                    <label>Args <span class="info" data-tip="Arguments passed to the speedtest CLI.">i</span></label>
                    <input type="text" name="speedtest_args" value="{{ settings.pulsewatch.speedtest.args }}" />
                  </div>
                  <div>
                    <label>Use network namespaces <span class="info" data-tip="Run speedtests inside netns for interface-based routing.">i</span></label>
                    <label class="form-check form-switch">
                      <input class="form-check-input" type="checkbox" name="speedtest_use_netns" {% if settings.pulsewatch.speedtest.use_netns %}checked{% endif %} />
                      <span class="form-check-label">Enabled</span>
                    </label>
                  </div>
                  <div>
                    <label>Netns Prefix <span class="info" data-tip="Namespace prefix (e.g., isp) used to build per-ISP netns names.">i</span></label>
                    <input type="text" name="speedtest_netns_prefix" value="{{ settings.pulsewatch.speedtest.netns_prefix }}" />
                  </div>
                </div>
                <div class="alert alert-info mt-3">
                  <div class="d-flex align-items-center">
                    <span class="me-2"><i class="ti ti-info-circle"></i></span>
                    <div>Speedtest All runs sequentially to avoid saturating a single 1G LAN uplink.</div>
                  </div>
                </div>
              </div>
            </div>

            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-3">Telegram</h4>
                <div class="form-grid">
                  <div>
                    <label>Pulsewatch Bot Token <span class="info" data-tip="Dedicated bot token for Pulsewatch alerts and actions.">i</span></label>
                    <input type="text" name="pulsewatch_bot_token" value="{{ settings.telegram.pulsewatch_bot_token }}" />
                  </div>
                  <div>
                    <label>Alert Channel ID <span class="info" data-tip="Override channel ID for Pulsewatch alerts.">i</span></label>
                    <input type="text" name="telegram_alert_channel_id" value="{{ settings.telegram.alert_channel_id }}" />
                  </div>
                </div>
              </div>
            </div>

            <div class="d-flex justify-content-end">
              <button type="submit" class="btn btn-primary">Save Monitoring & Alerts</button>
            </div>
          </div>

          <div class="tab-pane" id="pulsewatch-dashboard">
            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-3">Pulsewatch ISP Summary Dashboard Settings</h4>
                <div class="form-grid">
                  <div>
                    <label>Default Target <span class="info" data-tip="Default target used by the Pulsewatch ISP Summary on the dashboard.">i</span></label>
                    <select name="pulsewatch_dashboard_default_target">
                      <option value="all" {% if settings.pulsewatch.dashboard.default_target == "all" %}selected{% endif %}>All targets</option>
                      {% for target in pulsewatch_targets %}
                        <option value="{{ target }}" {% if settings.pulsewatch.dashboard.default_target == target %}selected{% endif %}>{{ target }}</option>
                      {% endfor %}
                    </select>
                  </div>
                  <div>
                    <label>Table refresh (seconds) <span class="info" data-tip="How often the ISP Summary table refreshes.">i</span></label>
                    <input type="number" name="pulsewatch_dashboard_refresh_seconds" value="{{ settings.pulsewatch.dashboard.refresh_seconds }}" />
                  </div>
                  <div>
                    <label>Loss history (minutes) <span class="info" data-tip="Minutes of loss history to show in the summary sparkline.">i</span></label>
                    <input type="number" name="pulsewatch_dashboard_loss_history_minutes" value="{{ settings.pulsewatch.dashboard.loss_history_minutes }}" />
                  </div>
                  <div>
                    <label>Pie chart default days <span class="info" data-tip="Default range for the Pulsewatch stability pie charts.">i</span></label>
                    <input type="number" name="pulsewatch_dashboard_pie_days" value="{{ settings.pulsewatch.dashboard.pie_default_days }}" />
                  </div>
                </div>
              </div>
            </div>

            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-3">Pulsewatch Stability Overview</h4>
                <div class="form-grid">
                  <div>
                    <label>Stable max (ms) <span class="info" data-tip="Average latency at or below this value is counted as Stable.">i</span></label>
                    <input type="number" name="pulsewatch_stability_stable_max_ms" value="{{ settings.pulsewatch.stability.stable_max_ms }}" />
                  </div>
                  <div>
                    <label>Unstable max (ms) <span class="info" data-tip="Average latency between Stable max and this value is counted as Unstable. Critical is above this.">i</span></label>
                    <input type="number" name="pulsewatch_stability_unstable_max_ms" value="{{ settings.pulsewatch.stability.unstable_max_ms }}" />
                  </div>
                  <div>
                    <label>Down source <span class="info" data-tip="Down slice is driven by WAN Ping status (current down/up).">i</span></label>
                    <input type="text" value="WAN Ping status" disabled />
                  </div>
                </div>
                <div class="help">These thresholds affect the Pulsewatch Stability Overview on the WAN Ping page.</div>
              </div>
            </div>

            <div class="d-flex justify-content-end">
              <button type="submit" class="btn btn-primary">Save Dashboard Settings</button>
            </div>
          </div>

          <div class="tab-pane" id="pulsewatch-danger">
            <div class="card mb-3">
              <div class="card-body">
                <h4 class="mb-2">Format Pulsewatch Database</h4>
                <div class="alert alert-warning">
                  <div class="d-flex align-items-center">
                    <span class="me-2"><i class="ti ti-alert-triangle"></i></span>
                    <div>Formatting removes Pulsewatch ping, speedtest, alerts, and rollup data. Settings are preserved.</div>
                  </div>
                </div>
                <label class="form-check">
                  <input class="form-check-input" type="checkbox" name="confirm_format" form="pulsewatch-format-form" />
                  <span class="form-check-label">I understand this will erase Pulsewatch data.</span>
                </label>
                <div class="mt-3">
                  <button type="submit" class="btn btn-danger" form="pulsewatch-format-form">Format Pulsewatch Database</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </form>
    </div>
  </div>
</div>

<form id="pulsewatch-format-form" method="post" action="/settings/pulsewatch/format"></form>

<div class="modal modal-blur fade" id="pulsewatch-spark-modal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="pulsewatch-spark-title">Loss History</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="text-muted small mb-2" id="pulsewatch-spark-range">Loss history window</div>
        <div id="pulsewatch-spark-modal-chart" class="pulsewatch-spark-modal-chart"></div>
        <div class="text-muted small mt-2">Loss history based on rollup results for the selected window.</div>
      </div>
    </div>
  </div>
</div>

  <div id="pulsewatch_stream_modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.55); align-items: center; justify-content: center; z-index: 1000;">
  <div style="background: #0f172a; color: #e2e8f0; border: 1px solid #1f2937; padding: 16px; border-radius: 10px; width: 95vw; max-width: 1400px; max-height: 90vh; display: flex; flex-direction: column;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <strong id="pulsewatch_stream_title">Live Ping</strong>
      <button type="button" id="pulsewatch_stream_close" style="border: none; background: transparent; font-size: 18px; color: #e2e8f0; cursor: pointer;">&times;</button>
    </div>
    <div id="pulsewatch_stream_targets" style="display: none; gap: 6px; flex-wrap: wrap; margin-bottom: 10px;"></div>
    <div style="font-size: 12px; color: #94a3b8; margin-bottom: 8px;">Live ping output. Closing the modal stops this manual ping.</div>
    <div id="pulsewatch_stream_grid" style="display: none; gap: 12px; overflow: auto; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); flex: 1;"></div>
    <pre id="pulsewatch_stream_output" style="flex: 1; overflow: auto; margin: 0; padding: 10px; background: #0b1020; border: 1px solid #1f2937; border-radius: 8px; white-space: pre-wrap;"></pre>
    <div style="margin-top: 12px; text-align: right;">
      <button type="button" class="btn btn-primary" id="pulsewatch_stream_stop">Stop</button>
    </div>
  </div>
</div>

<div id="pulsewatch_stream_detail_modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65); align-items: center; justify-content: center; z-index: 1001;">
  <div style="background: #0f172a; color: #e2e8f0; border: 1px solid #1f2937; padding: 16px; border-radius: 10px; width: 80vw; max-width: 1100px; max-height: 80vh; display: flex; flex-direction: column;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <strong id="pulsewatch_stream_detail_title">ISP Detail</strong>
      <button type="button" id="pulsewatch_stream_detail_close" style="border: none; background: transparent; font-size: 18px; color: #e2e8f0; cursor: pointer;">&times;</button>
    </div>
    <pre id="pulsewatch_stream_detail_output" style="flex: 1; overflow: auto; margin: 0; padding: 10px; background: #0b1020; border: 1px solid #1f2937; border-radius: 8px; white-space: pre-wrap;"></pre>
    <div style="margin-top: 12px; text-align: right;">
      <button type="button" class="btn btn-primary" id="pulsewatch_stream_detail_ok">Close</button>
    </div>
  </div>
</div>

<div id="pulsewatch_speedtest_modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.55); align-items: center; justify-content: center; z-index: 1002;">
  <div style="background: #0f172a; color: #e2e8f0; border: 1px solid #1f2937; padding: 20px; border-radius: 12px; width: 90vw; max-width: 720px; display: flex; flex-direction: column; gap: 14px;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <strong id="pulsewatch_speedtest_title">Speedtest</strong>
      <button type="button" id="pulsewatch_speedtest_close" style="border: none; background: transparent; font-size: 18px; color: #e2e8f0; cursor: pointer;">&times;</button>
    </div>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 14px;">
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="font-size: 42px; font-weight: 700;" id="pulsewatch_speedtest_download_number">0</div>
          <div style="text-align: right;">
            <div style="font-size: 12px; color: #94a3b8;">Download Mbps</div>
            <div id="pulsewatch_speedtest_status" style="font-size: 12px; color: #94a3b8; margin-top: 4px;">Waiting to start…</div>
          </div>
        </div>
        <div style="height: 10px; background: #1f2937; border-radius: 999px; overflow: hidden;">
          <div id="pulsewatch_speedtest_download_bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #22c55e, #38bdf8); transition: width 0.4s ease;"></div>
        </div>
      </div>
      <div style="display: flex; flex-direction: column; gap: 8px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="font-size: 42px; font-weight: 700;" id="pulsewatch_speedtest_upload_number">0</div>
          <div style="text-align: right;">
            <div style="font-size: 12px; color: #94a3b8;">Upload Mbps</div>
          </div>
        </div>
        <div style="height: 10px; background: #1f2937; border-radius: 999px; overflow: hidden;">
          <div id="pulsewatch_speedtest_upload_bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #f97316, #facc15); transition: width 0.4s ease;"></div>
        </div>
      </div>
    </div>
    <div id="pulsewatch_speedtest_loading" style="display: none; align-items: center; gap: 10px; color: #94a3b8; font-size: 13px;">
      <div style="width: 18px; height: 18px; border: 2px solid #1f2937; border-top-color: #38bdf8; border-radius: 50%; animation: spin 0.9s linear infinite;"></div>
      <div>Speedtest ongoing…</div>
    </div>
    <div id="pulsewatch_speedtest_details" style="font-size: 13px; color: #cbd5f5;">Upload: -- Mbps · Ping: -- ms · Server: --</div>
    <div style="display: flex; gap: 8px; align-items: center; justify-content: space-between;">
      <div style="flex: 1;">
        <label style="font-size: 12px; color: #94a3b8;">Server</label>
        <select id="pulsewatch_speedtest_server" style="width: 100%; background: #0b1020; color: #e2e8f0; border: 1px solid #1f2937; border-radius: 8px; padding: 6px 8px; font-size: 12px;">
          <option value="">Automatic</option>
        </select>
      </div>
      <button type="button" class="btn btn-primary" id="pulsewatch_speedtest_run" style="white-space: nowrap;">Run Test</button>
    </div>
  </div>
</div>

<div id="pulsewatch_speedtest_all_modal" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.55); align-items: center; justify-content: center; z-index: 1003;">
  <div style="background: #0f172a; color: #e2e8f0; border: 1px solid #1f2937; padding: 20px; border-radius: 12px; width: 95vw; max-width: 1200px; max-height: 90vh; display: flex; flex-direction: column; gap: 14px;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <strong>Speedtest All ISPs</strong>
      <button type="button" id="pulsewatch_speedtest_all_close" style="border: none; background: transparent; font-size: 18px; color: #e2e8f0; cursor: pointer;">&times;</button>
    </div>
    <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: baseline;">
      <div style="font-size: 24px; font-weight: 700;" id="pulsewatch_speedtest_all_download">Total Download: -- Mbps</div>
      <div style="font-size: 24px; font-weight: 700;" id="pulsewatch_speedtest_all_upload">Total Upload: -- Mbps</div>
    </div>
    <div style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap;">
      <div style="min-width: 240px;">
        <label style="font-size: 12px; color: #94a3b8;">Server (applies to all ISPs)</label>
        <select id="pulsewatch_speedtest_all_server" style="width: 100%; background: #0b1020; color: #e2e8f0; border: 1px solid #1f2937; border-radius: 8px; padding: 6px 8px; font-size: 12px;">
          <option value="">Automatic</option>
        </select>
      </div>
      <button type="button" class="btn btn-primary" id="pulsewatch_speedtest_all_start">Start</button>
      <button type="button" class="btn btn-outline-primary" id="pulsewatch_speedtest_all_stop_run">Stop</button>
    </div>
    <div id="pulsewatch_speedtest_all_grid" style="display: grid; gap: 14px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); overflow: auto;"></div>
    <div style="text-align: right;">
      <button type="button" class="btn btn-primary" id="pulsewatch_speedtest_all_stop">Close</button>
    </div>
  </div>
</div>

<div class="modal modal-blur fade" id="pulsewatch-reachability-modal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Fix Reachability (Source IP to Target)</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="text-muted mb-3">
          This action tries to recover when a source IP on the server cannot reach its first ping target.
          It re-applies netplan and restarts the host network service. Use this if reachability shows
          <strong>Unreachable</strong> even though the IPs are already assigned.
        </div>
        <div class="alert alert-info">
          This helper was added to recover when IP bindings stop working after netplan changes.
          VM environments sometimes need a network restart before source-bound pings succeed.
        </div>
        <ul class="text-muted small mb-3">
          <li>Step 1: Re-apply netplan for Pulsewatch IP bindings.</li>
          <li>Step 2: Restart host networking (systemd-networkd or networking).</li>
          <li>Step 3: Re-check reachability status.</li>
        </ul>
        <div class="text-muted small">Note: If the VM bridge or upstream router is down, this will not restore connectivity.</div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" id="pulsewatch_reachability_refresh">Refresh Reachability</button>
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-warning" id="pulsewatch_reachability_run" disabled>Fix Reachability</button>
      </div>
    </div>
  </div>
</div>

<style>
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
  @keyframes glow {
    0% { box-shadow: 0 0 0 rgba(56, 189, 248, 0.0); }
    50% { box-shadow: 0 0 14px rgba(56, 189, 248, 0.45); }
    100% { box-shadow: 0 0 0 rgba(56, 189, 248, 0.0); }
  }
</style>

<script>
  const pulsewatchTabLinks = document.querySelectorAll("#pulsewatch-tabs a[data-bs-toggle=\"tab\"]");
  const storedPulsewatchTab = localStorage.getItem("pulsewatch_active_tab");
  const hashPulsewatchTab = window.location.hash;
  const initialPulsewatchTab = (hashPulsewatchTab && document.querySelector(`#pulsewatch-tabs a[href="${hashPulsewatchTab}"]`))
    ? hashPulsewatchTab
    : storedPulsewatchTab;
  if (initialPulsewatchTab) {
    const tabEl = document.querySelector(`#pulsewatch-tabs a[href="${initialPulsewatchTab}"]`);
    if (tabEl && window.bootstrap?.Tab) {
      new window.bootstrap.Tab(tabEl).show();
    }
  }
  pulsewatchTabLinks.forEach((link) => {
    link.addEventListener("shown.bs.tab", (event) => {
      const href = event.target.getAttribute("href");
      if (href) {
        localStorage.setItem("pulsewatch_active_tab", href);
      }
    });
  });
</script>
<script>
  let latencySeries = {{ pulse_latency_series | tojson }};
  const chartEl = document.getElementById("pulsewatch-latency-chart");
  const legendEl = document.getElementById("pulsewatch-latency-legend");
  const filterEl = document.getElementById("pulsewatch-core-filter");
  const rangeEl = document.getElementById("pulsewatch-range-filter");
  const targetEl = document.getElementById("pulsewatch-target-filter");
  const fromEl = document.getElementById("pulsewatch-from-filter");
  const toEl = document.getElementById("pulsewatch-to-filter");

  const tooltip = document.createElement("div");
  tooltip.style.position = "absolute";
  tooltip.style.background = "#111827";
  tooltip.style.color = "#fff";
  tooltip.style.padding = "6px 8px";
  tooltip.style.borderRadius = "6px";
  tooltip.style.fontSize = "12px";
  tooltip.style.pointerEvents = "none";
  tooltip.style.display = "none";
  tooltip.style.zIndex = "10";
  if (chartEl) {
    chartEl.appendChild(tooltip);
  }

  const toEpoch = (value) => {
    if (!value) return null;
    const rawValue = String(value).trim();
    if (!rawValue) return null;
    const direct = Date.parse(rawValue);
    if (!Number.isNaN(direct)) return direct;
    const hasTimezone = /Z$|[+-]\\d{2}:?\\d{2}$/.test(rawValue);
    if (hasTimezone) return null;
    const withUtc = Date.parse(`${rawValue}Z`);
    return Number.isNaN(withUtc) ? null : withUtc;
  };

  const toLocalEpoch = (value) => {
    if (!value) return null;
    const parsed = new Date(value).getTime();
    if (!Number.isNaN(parsed)) return parsed;
    const fallback = Date.parse(value);
    return Number.isNaN(fallback) ? null : fallback;
  };

  const resolveWindow = (series, hours, fromTs, toTs) => {
    const allTimes = series.flatMap((item) => item.points.map((point) => toEpoch(point.ts))).filter(Boolean);
    if (!allTimes.length) return null;
    const minAll = Math.min(...allTimes);
    const maxAll = Math.max(...allTimes);
    let start;
    let end;
    if (fromTs || toTs) {
      start = fromTs ?? minAll;
      end = toTs ?? maxAll;
    } else {
      end = maxAll;
      start = end - hours * 60 * 60 * 1000;
    }
    if (start > end) {
      const temp = start;
      start = end;
      end = temp;
    }
    return { start, end };
  };

  const renderChart = (coreId, hours, target, fromTs, toTs) => {
    if (!chartEl) return;
    const filtered = latencySeries.filter((item) => {
      if (coreId !== "all" && item.core_id !== coreId) return false;
      if (target !== "all" && item.target !== target) return false;
      return true;
    });
    const window = resolveWindow(filtered, hours, fromTs, toTs);
    if (!window) {
      chartEl.innerHTML = "<div class='text-muted'>No latency data available.</div>";
      return;
    }
    const series = filtered.map((item) => ({
      ...item,
      points: item.points.filter((point) => {
        const ts = toEpoch(point.ts);
        return ts !== null && ts >= window.start && ts <= window.end;
      }),
    }));
    chartEl.innerHTML = "";
    legendEl.innerHTML = "";
    chartEl.appendChild(tooltip);
    if (!series.length) {
      chartEl.innerHTML = "<div class='text-muted'>No data for selected core.</div>";
      return;
    }

    const rawPoints = series.flatMap((item) =>
      item.points.map((point) => ({ x: toEpoch(point.ts), y: point.value }))
    ).filter((point) => point.x !== null && point.y !== null);
    if (!rawPoints.length) {
      chartEl.innerHTML = "<div class='text-muted'>No latency data available.</div>";
      return;
    }

    const minX = window.start;
    const maxX = window.end;
    const renderSeries = series.map((item) => {
      const points = item.points
        .map((point) => ({ x: toEpoch(point.ts), y: point.value }))
        .filter((point) => point.x !== null && point.y !== null)
        .sort((a, b) => a.x - b.x);
      if (!points.length) return { ...item, renderPoints: [] };
      return { ...item, renderPoints: points };
    });

    const allPoints = renderSeries.flatMap((item) => item.renderPoints);
    const minY = Math.min(...allPoints.map((point) => point.y));
    const maxY = Math.max(...allPoints.map((point) => point.y));
    const width = chartEl.clientWidth || 600;
    const height = 240;
    const pad = 24;
    const spanX = Math.max(maxX - minX, 1);
    const spanY = Math.max(maxY - minY, 1);

    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", height + pad * 1.5);
    svg.setAttribute("viewBox", `0 0 ${width} ${height + pad * 1.5}`);

    const axis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    axis.setAttribute("x1", pad);
    axis.setAttribute("x2", width - pad);
    axis.setAttribute("y1", height);
    axis.setAttribute("y2", height);
    axis.setAttribute("stroke", "#e5e7eb");
    axis.setAttribute("stroke-width", "1");
    svg.appendChild(axis);

    const niceStep = (range) => {
      const rough = range / 5;
      const power = Math.pow(10, Math.floor(Math.log10(Math.max(rough, 1))));
      const scaled = rough / power;
      if (scaled <= 1) return 1 * power;
      if (scaled <= 2) return 2 * power;
      if (scaled <= 5) return 5 * power;
      return 10 * power;
    };

    const yStep = niceStep(maxY - minY);
    const yStart = Math.floor(minY / yStep) * yStep;
    const yEnd = Math.ceil(maxY / yStep) * yStep;
    for (let y = yStart; y <= yEnd; y += yStep) {
      const yPos = height - ((y - minY) / spanY) * (height - pad);
      const grid = document.createElementNS("http://www.w3.org/2000/svg", "line");
      grid.setAttribute("x1", pad);
      grid.setAttribute("x2", width - pad);
      grid.setAttribute("y1", yPos.toFixed(1));
      grid.setAttribute("y2", yPos.toFixed(1));
      grid.setAttribute("stroke", "#f3f4f6");
      grid.setAttribute("stroke-width", "1");
      svg.appendChild(grid);

      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", pad - 6);
      label.setAttribute("y", yPos + 3);
      label.setAttribute("text-anchor", "end");
      label.setAttribute("fill", "#9ca3af");
      label.setAttribute("font-size", "10");
      label.textContent = `${y}`;
      svg.appendChild(label);
    }

    const formatTimeLabel = (ts, mode) => {
      const date = new Date(ts);
      if (mode === "date") {
        return date.toLocaleDateString("en-PH", { month: "numeric", day: "numeric", year: "2-digit" });
      }
      return date.toLocaleTimeString("en-PH", { hour: "numeric", minute: "2-digit", hour12: true });
    };

    const rangeHours = Math.max((maxX - minX) / (1000 * 60 * 60), 1);
    const timeMode = rangeHours >= 24 ? "date" : "time";
    const xTicks = [];
    if (timeMode === "date") {
      const start = new Date(minX);
      start.setHours(0, 0, 0, 0);
      for (let t = start.getTime(); t <= maxX; t += 24 * 60 * 60 * 1000) {
        if (t >= minX) xTicks.push(t);
      }
      if (!xTicks.length) {
        xTicks.push(minX, maxX);
      }
    } else {
      const tickStep = rangeHours <= 6 ? 1 : 2;
      const start = new Date(minX);
      start.setMinutes(0, 0, 0);
      const startTs = start.getTime();
      for (let t = startTs; t <= maxX; t += tickStep * 60 * 60 * 1000) {
        if (t >= minX) xTicks.push(t);
      }
    }
    if (!xTicks.length) {
      xTicks.push(minX);
      if (maxX !== minX) xTicks.push(maxX);
    }
    xTicks.forEach((t) => {
      const xPos = pad + ((t - minX) / spanX) * (width - pad * 2);
      const tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
      tick.setAttribute("x1", xPos.toFixed(1));
      tick.setAttribute("x2", xPos.toFixed(1));
      tick.setAttribute("y1", height);
      tick.setAttribute("y2", height + 4);
      tick.setAttribute("stroke", "#e5e7eb");
      tick.setAttribute("stroke-width", "1");
      svg.appendChild(tick);

      const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
      label.setAttribute("x", xPos.toFixed(1));
      label.setAttribute("y", height + 18);
      label.setAttribute("text-anchor", "middle");
      label.setAttribute("fill", "#9ca3af");
      label.setAttribute("font-size", "10");
      label.textContent = formatTimeLabel(t, timeMode);
      svg.appendChild(label);
    });

    const labelX = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelX.setAttribute("x", width - pad);
    labelX.setAttribute("y", height + 24);
    labelX.setAttribute("text-anchor", "end");
    labelX.setAttribute("fill", "#9ca3af");
    labelX.setAttribute("font-size", "10");
    labelX.textContent = "Time (PHT)";
    svg.appendChild(labelX);

    const labelY = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelY.setAttribute("x", pad);
    labelY.setAttribute("y", 12);
    labelY.setAttribute("text-anchor", "start");
    labelY.setAttribute("fill", "#9ca3af");
    labelY.setAttribute("font-size", "10");
    labelY.textContent = "Latency (ms)";
    svg.appendChild(labelY);

    renderSeries.forEach((item) => {
      if (!item.renderPoints.length) return;
      const sorted = item.renderPoints.slice().sort((a, b) => a.x - b.x);
      const gapThresholdMs = 2 * 60 * 1000;
      let segment = [];
      const flushSegment = () => {
        if (segment.length < 2) {
          segment = [];
          return;
        }
        const path = segment
          .map((point) => {
            const x = pad + ((point.x - minX) / spanX) * (width - pad * 2);
            const y = height - ((point.y - minY) / spanY) * (height - pad);
            return `${x.toFixed(1)},${y.toFixed(1)}`;
          })
          .join(" ");
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("points", path);
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", item.color);
        polyline.setAttribute("stroke-width", "2");
        polyline.setAttribute("opacity", "0.9");
        polyline.setAttribute("data-series-id", item.id);
        svg.appendChild(polyline);
        segment = [];
      };
      let lastPoint = null;
      sorted.forEach((point) => {
        if (lastPoint && point.x - lastPoint.x > gapThresholdMs) {
          flushSegment();
        }
        segment.push(point);
        lastPoint = point;
      });
      flushSegment();

      const legend = document.createElement("div");
      legend.className = "d-flex align-items-center gap-2";
      legend.setAttribute("data-series-id", item.id);
      legend.innerHTML = `<span style="width:12px;height:12px;border-radius:50%;background:${item.color};display:inline-block;"></span><span class="small text-muted">${item.name}</span>`;
      legendEl.appendChild(legend);
    });

    const overlay = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    overlay.setAttribute("x", pad);
    overlay.setAttribute("y", 0);
    overlay.setAttribute("width", width - pad * 2);
    overlay.setAttribute("height", height);
    overlay.setAttribute("fill", "transparent");
    overlay.style.cursor = "default";
    svg.appendChild(overlay);

    overlay.addEventListener("mousemove", (event) => {
      const rect = svg.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const rel = Math.min(Math.max(x - pad, 0), width - pad * 2);
      const targetTs = minX + (rel / (width - pad * 2)) * spanX;
      const details = [];
      const activeList = activeIds.size ? Array.from(activeIds) : null;
      series.forEach((item) => {
        if (activeList && !activeIds.has(item.id)) {
          return;
        }
        const points = item.points
          .map((point) => ({ x: toEpoch(point.ts), y: point.value }))
          .filter((point) => point.x !== null && point.y !== null);
        if (!points.length) return;
        let nearest = points[0];
        let best = Math.abs(points[0].x - targetTs);
        for (const point of points) {
          const diff = Math.abs(point.x - targetTs);
          if (diff < best) {
            best = diff;
            nearest = point;
          }
        }
        details.push({ name: item.name, color: item.color, value: nearest.y });
      });
      const timeLabel = new Date(targetTs).toLocaleString("en-PH", { hour12: true });
      tooltip.innerHTML = `<div class="fw-semibold mb-1">${timeLabel}</div>` +
        details.map((item) => `<div style="display:flex;gap:6px;align-items:center;"><span style="width:8px;height:8px;border-radius:50%;background:${item.color};display:inline-block;"></span><span>${item.name}: ${item.value.toFixed(1)} ms</span></div>`).join("");
      tooltip.style.left = `${Math.min(x + 12, rect.width - 220)}px`;
      tooltip.style.top = `${Math.max(8, event.clientY - rect.top - 60)}px`;
      tooltip.style.display = "block";
    });

    overlay.addEventListener("mouseleave", () => {
      tooltip.style.display = "none";
    });

    overlay.addEventListener("wheel", (event) => {
      if (!event.ctrlKey) return;
      event.preventDefault();
      const rect = svg.getBoundingClientRect();
      const x = Math.min(Math.max(event.clientX - rect.left, pad), width - pad);
      const rel = Math.min(Math.max(x - pad, 0), width - pad * 2);
      const anchorTs = minX + (rel / (width - pad * 2)) * spanX;
      const { fromTs, toTs } = syncRangeState();
      const window = resolveZoomWindow(getRangeHours(), fromTs, toTs);
      const currentStart = window.start;
      const currentEnd = window.end;
      const scale = event.deltaY < 0 ? 0.8 : 1.25;
      const newStart = anchorTs - (anchorTs - currentStart) * scale;
      const newEnd = anchorTs + (currentEnd - anchorTs) * scale;
      setWindow(newStart, newEnd);
      updateChart();
    }, { passive: false });

    chartEl.appendChild(svg);

    const activeIds = new Set();
    const setOpacity = () => {
      const lines = svg.querySelectorAll("polyline[data-series-id]");
      const hasSelection = activeIds.size > 0;
      lines.forEach((line) => {
        const id = line.getAttribute("data-series-id");
        line.setAttribute("opacity", hasSelection && !activeIds.has(id) ? "0.2" : "0.95");
      });
      const labels = legendEl.querySelectorAll("[data-series-id]");
      labels.forEach((label) => {
        const id = label.getAttribute("data-series-id");
        label.style.opacity = hasSelection && !activeIds.has(id) ? "0.4" : "1";
        label.style.fontWeight = activeIds.has(id) ? "600" : "400";
      });
    };

    legendEl.querySelectorAll("[data-series-id]").forEach((label) => {
      const seriesId = label.getAttribute("data-series-id");
      label.style.cursor = "pointer";
      label.addEventListener("click", () => {
        if (activeIds.has(seriesId)) {
          activeIds.delete(seriesId);
        } else {
          activeIds.add(seriesId);
        }
        setOpacity();
      });
    });
  };

  const getRangeHours = () => {
    const parsed = parseInt(rangeEl.value, 10);
    return Number.isNaN(parsed) ? 24 : parsed;
  };

  const formatLocalInput = (ts) => {
    const dt = new Date(ts);
    if (Number.isNaN(dt.getTime())) return "";
    const pad = (n) => String(n).padStart(2, "0");
    const yyyy = dt.getFullYear();
    const mm = pad(dt.getMonth() + 1);
    const dd = pad(dt.getDate());
    const hh = pad(dt.getHours());
    const min = pad(dt.getMinutes());
    return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
  };

  const resolveZoomWindow = (hours, fromTs, toTs) => {
    let start;
    let end;
    if (fromTs || toTs) {
      start = fromTs ?? toTs;
      end = toTs ?? fromTs;
    } else {
      end = Date.now();
      start = end - hours * 60 * 60 * 1000;
    }
    if (start > end) {
      const temp = start;
      start = end;
      end = temp;
    }
    return { start, end };
  };

  const toIsoString = (value) => {
    if (!value) return null;
    const dt = new Date(value);
    if (Number.isNaN(dt.getTime())) return null;
    return dt.toISOString();
  };

  const syncRangeState = () => {
    const fromTs = toLocalEpoch(fromEl.value);
    const toTs = toLocalEpoch(toEl.value);
    const hasWindow = Boolean(fromTs || toTs);
    rangeEl.disabled = hasWindow;
    return { fromTs, toTs };
  };

  const fetchSeries = async (hours, fromIso, toIso) => {
    const params = new URLSearchParams();
    params.set("core_id", filterEl.value);
    params.set("target", targetEl.value);
    params.set("hours", String(hours));
    if (fromIso) params.set("start", fromIso);
    if (toIso) params.set("end", toIso);
    const response = await fetch(`/pulsewatch/latency-series?${params.toString()}`, {
      headers: { "Accept": "application/json" },
      cache: "no-store",
    });
    if (!response.ok) {
      throw new Error("Failed to load latency series");
    }
    const payload = await response.json();
    latencySeries = payload.series || [];
  };

  const updateChart = async () => {
    const { fromTs, toTs } = syncRangeState();
    const hours = getRangeHours();
    const fromIso = toIsoString(fromEl.value);
    const toIso = toIsoString(toEl.value);
    try {
      await fetchSeries(hours, fromIso, toIso);
    } catch (err) {
      console.error(err);
    }
    renderChart(filterEl.value, hours, targetEl.value, fromTs, toTs);
  };

  if (filterEl) {
    filterEl.addEventListener("change", () => {
      updateChart();
    });
  }
  if (rangeEl) {
    rangeEl.addEventListener("change", () => {
      if (fromEl) fromEl.value = "";
      if (toEl) toEl.value = "";
      rangeEl.disabled = false;
      updateChart();
    });
  }
  if (targetEl) {
    targetEl.addEventListener("change", () => {
      updateChart();
    });
  }
  if (fromEl) {
    fromEl.addEventListener("change", () => {
      updateChart();
    });
  }
  if (toEl) {
    toEl.addEventListener("change", () => {
      updateChart();
    });
  }
  const setWindow = (start, end) => {
    fromEl.value = formatLocalInput(start);
    toEl.value = formatLocalInput(end);
  };


  window.addEventListener("resize", () => {
    const { fromTs, toTs } = syncRangeState();
    renderChart(filterEl ? filterEl.value : "all", getRangeHours(), targetEl.value, fromTs, toTs);
  });

  updateChart();
</script>
<script>
  const summaryTargetEl = document.getElementById("pulsewatch-summary-target");
  const summaryBodyEl = document.getElementById("pulsewatch-summary-body");
  const summaryTotalEl = document.getElementById("pulsewatch-summary-total");
  const summaryLastEl = document.getElementById("pulsewatch-summary-last");
  const summaryRefresh = summaryBodyEl ? parseInt(summaryBodyEl.dataset.refresh || "2", 10) : 2;
  const summaryLossMinutes = summaryBodyEl ? parseInt(summaryBodyEl.dataset.lossMinutes || "120", 10) : 120;
  const summaryRangeLabel = summaryBodyEl ? summaryBodyEl.dataset.rangeLabel || "" : "";

  const sparkModalEl = document.getElementById("pulsewatch-spark-modal");
  const sparkTitleEl = document.getElementById("pulsewatch-spark-title");
  const sparkRangeEl = document.getElementById("pulsewatch-spark-range");
  const sparkChartEl = document.getElementById("pulsewatch-spark-modal-chart");
  let sparkChartInstance = null;
  if (sparkModalEl && sparkModalEl.parentElement && sparkModalEl.parentElement !== document.body) {
    document.body.appendChild(sparkModalEl);
  }

  const escapeHtml = (value) => String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#39;");

  const renderSparklineModal = async (btn) => {
    if (!sparkChartEl) return;
    const label = btn?.dataset.label || "Loss History";
    const color = btn?.dataset.color || "#2fb344";
    const rowId = btn?.dataset.rowId || "";
    if (sparkTitleEl) {
      sparkTitleEl.textContent = `${label} · Loss History`;
    }
    if (sparkRangeEl) {
      sparkRangeEl.textContent = summaryRangeLabel || "Loss history window";
    }
    if (sparkChartInstance) {
      sparkChartInstance.destroy();
      sparkChartInstance = null;
    }
    sparkChartEl.innerHTML = "<div class='text-muted'>Loading chart...</div>";
    if (!rowId) {
      sparkChartEl.innerHTML = "<div class='text-muted'>No data available.</div>";
      return;
    }
    const target = summaryTargetEl ? summaryTargetEl.value : "all";
    const params = new URLSearchParams({
      row_id: rowId,
      target,
      loss_minutes: String(summaryLossMinutes),
    });
    try {
      const res = await fetch(`/pulsewatch/loss_series?${params.toString()}`, { headers: { "Accept": "application/json" } });
      if (!res.ok) {
        sparkChartEl.innerHTML = "<div class='text-muted'>No data available.</div>";
        return;
      }
      const payload = await res.json();
      const series = (payload.series || []).map((item) => ({ x: item.ts, y: item.value }));
      if (!series.length) {
        sparkChartEl.innerHTML = "<div class='text-muted'>No data available.</div>";
        return;
      }
      sparkChartEl.innerHTML = "";
      const formatTime = (value) =>
        new Date(value).toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" });
      const formatDate = (value) =>
        new Date(value).toLocaleDateString("en-US", { month: "short", day: "2-digit" });
      const hours = Math.max(1, Math.round(summaryLossMinutes / 60));
      const labelFormatter = hours <= 24 ? formatTime : formatDate;
      const options = {
        chart: {
          type: "line",
          height: 220,
          toolbar: { show: false },
          zoom: { enabled: false },
        },
        stroke: { curve: "straight", width: 2 },
        colors: [color],
        markers: { size: 0 },
        series: [{ name: "Loss", data: series }],
        xaxis: {
          type: "datetime",
          labels: { formatter: labelFormatter },
        },
        yaxis: {
          min: 0,
          max: 100,
          tickAmount: 2,
          labels: { formatter: (val) => `${val}%` },
        },
        tooltip: {
          x: { formatter: (val) => new Date(val).toLocaleString("en-US") },
          y: { formatter: (val) => `${val}%` },
        },
        grid: { strokeDashArray: 4 },
      };
      sparkChartInstance = new ApexCharts(sparkChartEl, options);
      sparkChartInstance.render();
    } catch (err) {
      sparkChartEl.innerHTML = "<div class='text-muted'>No data available.</div>";
    }
  };

  document.addEventListener("click", (event) => {
    const btn = event.target.closest(".pulsewatch-spark-btn");
    if (!btn) return;
    renderSparklineModal(btn);
  });

  const renderSummaryRows = (rows) => {
    if (!summaryBodyEl) return;
    summaryBodyEl.innerHTML = rows.map((row) => {
      const speed = row.speed || {};
      const lossMax = row.loss_max === null || row.loss_max === undefined ? "n/a" : `${row.loss_max}%`;
      const avgMax = row.avg_max === null || row.avg_max === undefined ? "n/a" : `${row.avg_max}ms`;
      const speedText = speed.download_mbps !== undefined && speed.download_mbps !== null
        ? `${speed.download_mbps} / ${speed.upload_mbps ?? "n/a"} Mbps, ${speed.latency_ms ?? "n/a"} ms`
        : "n/a";
      const downtime = row.total_samples ? `${row.down_samples}/${row.total_samples}` : "n/a";
      const label = escapeHtml(row.label || "ISP");
      const sourceIp = escapeHtml(row.source_ip || "n/a");
      const lastCheck = escapeHtml(row.last_check || "n/a");
      const color = row.color || "#2fb344";
      const rowId = escapeHtml(row.row_id || "");
      const lossPoints = row.loss_points || "";
      const lossPointsLarge = row.loss_points_large || lossPoints;
      const sparkCell = lossPoints
        ? `<button type="button" class="btn btn-link p-0 pulsewatch-spark-btn" data-bs-toggle="modal" data-bs-target="#pulsewatch-spark-modal" data-row-id="${rowId}" data-label="${label}" data-points="${lossPoints}" data-points-large="${lossPointsLarge}" data-color="${color}">
            <svg width="120" height="30" viewBox="0 0 120 30"><polyline points="${lossPoints}" fill="none" stroke="${color}" stroke-width="2" /></svg>
          </button>`
        : "<span class='text-muted'>n/a</span>";
      return `
        <tr>
          <td class="fw-semibold">${label}</td>
          <td>${sourceIp}</td>
          <td>${lastCheck}</td>
          <td>${lossMax}</td>
          <td>${avgMax}</td>
          <td>${sparkCell}</td>
          <td>${downtime}</td>
          <td class="text-muted">${speedText}</td>
        </tr>
      `;
    }).join("");
  };

  const fetchSummary = async () => {
    if (!summaryBodyEl) return;
    const target = summaryTargetEl ? summaryTargetEl.value : "all";
    const params = new URLSearchParams({
      target,
      loss_minutes: String(summaryLossMinutes),
    });
    try {
      const res = await fetch(`/pulsewatch/summary?${params.toString()}`, { headers: { "Accept": "application/json" } });
      if (!res.ok) return;
      const data = await res.json();
      if (summaryTotalEl) summaryTotalEl.textContent = data.total ?? "0";
      if (summaryLastEl) summaryLastEl.textContent = data.last_check || "n/a";
      renderSummaryRows(data.rows || []);
    } catch (err) {
      // ignore
    }
  };

  const statusTabLink = document.querySelector('#pulsewatch-tabs a[href="#pulsewatch-status"]');

  const startSummaryLoop = () => {
    if (summaryTargetEl) {
      summaryTargetEl.addEventListener("change", fetchSummary);
    }
    fetchSummary();
    setInterval(fetchSummary, Math.max(summaryRefresh, 2) * 1000);
  };

  if (summaryBodyEl) {
    if (!statusTabLink || statusTabLink.classList.contains("active")) {
      startSummaryLoop();
    } else {
      statusTabLink.addEventListener("shown.bs.tab", () => {
        startSummaryLoop();
      }, { once: true });
    }
  }
</script>
<script>
  const modal = document.getElementById("pulsewatch_modal");
  const closeBtn = document.getElementById("pulsewatch_modal_close");
  const okBtn = document.getElementById("pulsewatch_modal_ok");
  const reachModal = document.getElementById("pulsewatch-reachability-modal");
  const reachRun = document.getElementById("pulsewatch_reachability_run");

  const closeModal = () => {
    if (modal) {
      modal.style.display = "none";
    }
  };

  if (closeBtn) {
    closeBtn.addEventListener("click", closeModal);
  }
  if (okBtn) {
    okBtn.addEventListener("click", closeModal);
  }

  const reachRefreshBtn = document.getElementById("pulsewatch_reachability_refresh");
  const reachFixBtn = document.getElementById("pulsewatch_reachability_fix");
  const reachLastEl = document.getElementById("pulsewatch_reachability_last");
  let hasUnreachable = false;

  const reachBadgeHtml = (status) => {
    if (status === "reachable") {
      return '<span class="badge bg-green-lt">Reachable</span>';
    }
    if (status === "unreachable") {
      return '<span class="badge bg-red-lt">Unreachable</span>';
    }
    if (status === "missing") {
      return '<span class="badge bg-gray-lt">Missing</span>';
    }
    return '<span class="badge bg-yellow-lt">Unknown</span>';
  };

  const updateReachability = (payload) => {
    if (!payload || !payload.items) return;
    hasUnreachable = false;
    const checkedAt = payload.checked_at || "n/a";
    if (reachLastEl) {
      reachLastEl.textContent = `Last check: ${checkedAt}`;
    }
    Object.entries(payload.items).forEach(([rowId, info]) => {
      const cell = document.querySelector(`.pulsewatch-reach-cell[data-row-id="${rowId}"]`);
      if (!cell) return;
      const lastCheck = info.last_check || "n/a";
      cell.innerHTML = `${reachBadgeHtml(info.status)}<div class="text-muted small mt-1">${lastCheck}</div>`;
      const hasSource = (info.source_ip || "").trim().length > 0;
      if (info.status === "unreachable" || (info.status === "missing" && hasSource)) {
        hasUnreachable = true;
      }
    });
    if (reachRun) {
      reachRun.disabled = !hasUnreachable;
    }
  };

  const fetchReachability = async (refresh = false) => {
    const params = new URLSearchParams();
    if (refresh) params.set("refresh", "1");
    const res = await fetch(`/pulsewatch/reachability?${params.toString()}`, {
      headers: { "Accept": "application/json" },
    });
    if (!res.ok) return;
    const payload = await res.json();
    updateReachability(payload);
  };

  if (reachRefreshBtn) {
    reachRefreshBtn.addEventListener("click", () => fetchReachability(true));
  }
  if (reachRun) {
    reachRun.addEventListener("click", async () => {
      reachRun.disabled = true;
      try {
        await fetch("/settings/pulsewatch/reachability/fix", { method: "POST" });
        await fetchReachability(true);
      } finally {
        reachRun.disabled = !hasUnreachable;
        if (reachModal) {
          const modalInstance = window.bootstrap?.Modal.getInstance(reachModal);
          if (modalInstance) modalInstance.hide();
        }
      }
    });
  }
  if (reachModal) {
    reachModal.addEventListener("shown.bs.modal", () => fetchReachability(true));
  }
  fetchReachability(false);
  setInterval(() => fetchReachability(false), 10 * 60 * 1000);
  if (modal) {
    modal.addEventListener("click", (event) => {
      if (event.target === modal) {
        closeModal();
      }
    });
  }

  const streamModal = document.getElementById("pulsewatch_stream_modal");
  const streamOutput = document.getElementById("pulsewatch_stream_output");
  const streamTitle = document.getElementById("pulsewatch_stream_title");
  const streamClose = document.getElementById("pulsewatch_stream_close");
  const streamStop = document.getElementById("pulsewatch_stream_stop");
  const streamTargets = document.getElementById("pulsewatch_stream_targets");
  const streamGrid = document.getElementById("pulsewatch_stream_grid");
  let streamSource = null;
  let streamBase = "";
  let streamParams = {};
  let streamMode = "single";
  const streamPanels = new Map();
  let streamLabelList = [];

  const extractLabel = (line) => {
    const markers = [" PING ", " missing ", " stopped"];
    for (const marker of markers) {
      const idx = line.indexOf(marker);
      if (idx > 0) {
        return line.slice(0, idx);
      }
    }
    return null;
  };

  const ensurePanel = (label, targets) => {
    if (!streamGrid) {
      return null;
    }
    if (streamPanels.has(label)) {
      return streamPanels.get(label);
    }
    const wrapper = document.createElement("div");
    wrapper.style.border = "1px solid #1f2937";
    wrapper.style.borderRadius = "8px";
    wrapper.style.padding = "8px";
    wrapper.style.background = "#0b1020";
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";

    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.marginBottom = "6px";
    const title = document.createElement("strong");
    title.textContent = label;
    header.appendChild(title);

    const pre = document.createElement("pre");
    pre.style.margin = "0";
    pre.style.padding = "8px";
    pre.style.background = "#0f172a";
    pre.style.border = "1px solid #1f2937";
    pre.style.borderRadius = "6px";
    pre.style.whiteSpace = "pre-wrap";
    pre.style.overflow = "auto";
    pre.style.maxHeight = "220px";

    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.justifyContent = "space-between";
    footer.style.alignItems = "center";
    footer.style.marginTop = "8px";

    const targetSelect = document.createElement("select");
    targetSelect.style.fontSize = "11px";
    targetSelect.style.padding = "2px 6px";
    targetSelect.style.maxWidth = "140px";
    targetSelect.style.background = "#0f172a";
    targetSelect.style.color = "#e2e8f0";
    targetSelect.style.border = "1px solid #1f2937";
    targetSelect.style.borderRadius = "6px";
    (targets || []).forEach((value, idx) => {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = value;
      if (idx === 0) {
        option.selected = true;
      }
      targetSelect.appendChild(option);
    });

    const buttonGroup = document.createElement("div");

    const freezeBtn = document.createElement("button");
    freezeBtn.type = "button";
    freezeBtn.textContent = "Freeze";
    freezeBtn.className = "btn btn-primary btn-sm";
    freezeBtn.style.fontSize = "11px";
    freezeBtn.style.padding = "2px 6px";
    freezeBtn.dataset.frozen = "false";
    freezeBtn.addEventListener("click", () => {
      const frozen = freezeBtn.dataset.frozen === "true";
      freezeBtn.dataset.frozen = frozen ? "false" : "true";
      freezeBtn.textContent = frozen ? "Freeze" : "Unfreeze";
    });

    const expandBtn = document.createElement("button");
    expandBtn.type = "button";
    expandBtn.textContent = "Expand";
    expandBtn.className = "btn btn-primary btn-sm";
    expandBtn.style.fontSize = "11px";
    expandBtn.style.padding = "2px 6px";
    expandBtn.style.marginLeft = "6px";
    expandBtn.addEventListener("click", () => {
      const detailModal = document.getElementById("pulsewatch_stream_detail_modal");
      const detailTitle = document.getElementById("pulsewatch_stream_detail_title");
      const detailOutput = document.getElementById("pulsewatch_stream_detail_output");
      if (!detailModal || !detailTitle || !detailOutput) {
        return;
      }
      detailTitle.textContent = label;
      detailOutput.textContent = pre.textContent || "";
      detailModal.style.display = "flex";
    });

    buttonGroup.appendChild(freezeBtn);
    buttonGroup.appendChild(expandBtn);
    footer.appendChild(targetSelect);
    footer.appendChild(buttonGroup);

    wrapper.appendChild(header);
    wrapper.appendChild(pre);
    wrapper.appendChild(footer);
    streamGrid.appendChild(wrapper);
    const panel = { wrapper, pre, freezeBtn, targetSelect };
    streamPanels.set(label, panel);
    return panel;
  };

  const buildStreamUrl = (baseUrl, params) => {
    const search = new URLSearchParams();
    Object.entries(params || {}).forEach(([key, value]) => {
      if (value) {
        search.set(key, value);
      }
    });
    const query = search.toString();
    return query ? `${baseUrl}?${query}` : baseUrl;
  };

  const renderTargets = (targets, baseUrl, params) => {
    if (!streamTargets) {
      return;
    }
    streamTargets.innerHTML = "";
    if (!targets || targets.length === 0) {
      streamTargets.style.display = "none";
      return;
    }
    streamTargets.style.display = "flex";
    targets.forEach((target, index) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.textContent = target;
      btn.className = "btn btn-primary btn-sm";
      if (index !== 0) {
        btn.style.opacity = "0.75";
      }
      btn.addEventListener("click", () => {
        streamParams = { ...params, target };
        openStream(streamTitle.textContent, buildStreamUrl(baseUrl, streamParams));
        Array.from(streamTargets.children).forEach((child) => {
          child.style.opacity = child === btn ? "1" : "0.75";
        });
      });
      streamTargets.appendChild(btn);
    });
  };

  const openStream = (title, url) => {
    if (!streamModal || !streamOutput) {
      return;
    }
    if (streamSource) {
      streamSource.close();
    }
    streamTitle.textContent = title;
    streamOutput.textContent = "";
    streamPanels.clear();
    if (streamGrid) {
      streamGrid.innerHTML = "";
    }
    streamModal.style.display = "flex";
    if (streamMode === "all") {
      if (streamGrid) {
        streamGrid.style.display = "grid";
      }
      streamOutput.style.display = "none";
    } else {
      if (streamGrid) {
        streamGrid.style.display = "none";
      }
      streamOutput.style.display = "block";
    }
    if (!url) {
      return;
    }
    streamSource = new EventSource(url);
    streamSource.onmessage = (event) => {
      if (streamMode === "all") {
        const line = event.data || "";
        let label = "";
        for (const candidate of streamLabelList) {
          if (line.startsWith(candidate + " ")) {
            label = candidate;
            break;
          }
        }
        if (!label) {
          label = extractLabel(line) || "";
        }
        if (!label || (streamLabelList.length && !streamLabelList.includes(label))) {
          return;
        }
        const panel = streamPanels.get(label);
        if (!panel) {
          return;
        }
        const message = line.startsWith(label + " ") ? line.slice(label.length + 1) : line;
        if (message.includes("missing source IP")) {
          return;
        }
        const selectedTarget = panel.targetSelect ? panel.targetSelect.value : "";
        if (selectedTarget && !message.includes(selectedTarget)) {
          return;
        }
        panel.pre.textContent += `${message}\n`;
        const detailModal = document.getElementById("pulsewatch_stream_detail_modal");
        const detailTitle = document.getElementById("pulsewatch_stream_detail_title");
        const detailOutput = document.getElementById("pulsewatch_stream_detail_output");
        if (detailModal && detailTitle && detailOutput && detailModal.style.display === "flex" && detailTitle.textContent === label) {
          detailOutput.textContent = panel.pre.textContent || "";
          detailOutput.scrollTop = detailOutput.scrollHeight;
        }
        if (panel.freezeBtn.dataset.frozen !== "true") {
          panel.pre.scrollTop = panel.pre.scrollHeight;
        }
      } else {
        streamOutput.textContent += `${event.data}\n`;
        streamOutput.scrollTop = streamOutput.scrollHeight;
      }
    };
    streamSource.addEventListener("done", () => {
      streamSource.close();
      streamSource = null;
    });
    streamSource.onerror = () => {
      if (streamSource) {
        streamSource.close();
        streamSource = null;
      }
      streamOutput.textContent += "Stream closed.\n";
    };
  };

  const startStreamAll = (url) => {
    if (!url) {
      return;
    }
    if (streamSource) {
      streamSource.close();
    }
    streamSource = new EventSource(url);
    streamSource.onmessage = (event) => {
      if (streamMode !== "all") {
        return;
      }
      const line = event.data || "";
      let label = "";
      for (const candidate of streamLabelList) {
        if (line.startsWith(candidate + " ")) {
          label = candidate;
          break;
        }
      }
      if (!label) {
        label = extractLabel(line) || "";
      }
      if (!label || (streamLabelList.length && !streamLabelList.includes(label))) {
        return;
      }
      const panel = streamPanels.get(label);
      if (!panel) {
        return;
      }
      const message = line.startsWith(label + " ") ? line.slice(label.length + 1) : line;
      if (message.includes("missing source IP")) {
        return;
      }
      const selectedTarget = panel.targetSelect ? panel.targetSelect.value : "";
      if (selectedTarget && !message.includes(selectedTarget)) {
        return;
      }
      panel.pre.textContent += `${message}\n`;
      const detailModal = document.getElementById("pulsewatch_stream_detail_modal");
      const detailTitle = document.getElementById("pulsewatch_stream_detail_title");
      const detailOutput = document.getElementById("pulsewatch_stream_detail_output");
      if (detailModal && detailTitle && detailOutput && detailModal.style.display === "flex" && detailTitle.textContent === label) {
        detailOutput.textContent = panel.pre.textContent || "";
        detailOutput.scrollTop = detailOutput.scrollHeight;
      }
      if (panel.freezeBtn.dataset.frozen !== "true") {
        panel.pre.scrollTop = panel.pre.scrollHeight;
      }
    };
    streamSource.addEventListener("done", () => {
      streamSource.close();
      streamSource = null;
    });
    streamSource.onerror = () => {
      if (streamSource) {
        streamSource.close();
        streamSource = null;
      }
    };
  };

  const openAllModal = (title) => {
    if (!streamModal || !streamOutput) {
      return;
    }
    if (streamSource) {
      streamSource.close();
      streamSource = null;
    }
    streamTitle.textContent = title;
    streamOutput.textContent = "";
    streamPanels.clear();
    if (streamGrid) {
      streamGrid.innerHTML = "";
    }
    streamModal.style.display = "flex";
    if (streamGrid) {
      streamGrid.style.display = "grid";
    }
    streamOutput.style.display = "none";
  };

  const openStreamWithTargets = (title, baseUrl, params, targets) => {
    streamMode = "single";
    streamBase = baseUrl;
    streamParams = params || {};
    const targetList = (targets || []).filter((value) => value && value.trim().length);
    if (targetList.length > 0) {
      streamParams = { ...streamParams, target: targetList[0] };
    }
    renderTargets(targetList, baseUrl, params);
    openStream(title, buildStreamUrl(baseUrl, streamParams));
  };

  const closeStream = () => {
    if (streamSource) {
      streamSource.close();
      streamSource = null;
    }
    if (streamModal) {
      streamModal.style.display = "none";
    }
    if (streamTargets) {
      streamTargets.innerHTML = "";
      streamTargets.style.display = "none";
    }
    if (streamGrid) {
      streamGrid.innerHTML = "";
      streamGrid.style.display = "none";
    }
    const detailModal = document.getElementById("pulsewatch_stream_detail_modal");
    if (detailModal) {
      detailModal.style.display = "none";
    }
    streamLabelList = [];
  };

  if (streamClose) {
    streamClose.addEventListener("click", closeStream);
  }
  if (streamStop) {
    streamStop.addEventListener("click", closeStream);
  }
  const detailModal = document.getElementById("pulsewatch_stream_detail_modal");
  const detailClose = document.getElementById("pulsewatch_stream_detail_close");
  const detailOk = document.getElementById("pulsewatch_stream_detail_ok");
  if (detailClose) {
    detailClose.addEventListener("click", () => {
      if (detailModal) {
        detailModal.style.display = "none";
      }
    });
  }
  if (detailOk) {
    detailOk.addEventListener("click", () => {
      if (detailModal) {
        detailModal.style.display = "none";
      }
    });
  }
  if (detailModal) {
    detailModal.addEventListener("click", (event) => {
      if (event.target === detailModal) {
        detailModal.style.display = "none";
      }
    });
  }
  if (streamModal) {
    streamModal.addEventListener("click", (event) => {
      if (event.target === streamModal) {
        closeStream();
      }
    });
  }

  const pingButtons = document.querySelectorAll(".pulsewatch-ping");
  pingButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const rowId = button.getAttribute("data-row-id");
      if (!rowId) {
        return;
      }
      const row = button.closest("tr");
      const addressInput = row ? row.querySelector("input[name$='_address']") : null;
      const targetInput = row ? row.querySelector("textarea[name$='_ping_targets']") : null;
      const labelCore = row ? row.querySelector("td:nth-child(1)") : null;
      const labelList = row ? row.querySelector("td:nth-child(2)") : null;
      const identifierInput = row ? row.querySelector("input[name$='_identifier']") : null;
      const sourceIp = addressInput ? (addressInput.value || "").trim() : "";
      const targets = targetInput ? (targetInput.value || "").trim().split("\n") : [];
      const identifier = identifierInput ? (identifierInput.value || "").trim() : "";
      const labelValue = identifier || (labelList ? labelList.textContent.trim() : "");
      const label = `${labelCore ? labelCore.textContent.trim() : ""} ${labelValue}`.trim();
      const params = {};
      if (sourceIp) {
        params.source_ip = sourceIp;
      }
      if (label) {
        params.label = label;
      }
      openStreamWithTargets("Live Ping (Single ISP)", `/isp/pulsewatch/ping/stream/${rowId}`, params, targets);
    });
  });

  const pingAllButton = document.getElementById("pulsewatch_ping_all");
  if (pingAllButton) {
    pingAllButton.addEventListener("click", () => {
      streamMode = "all";
      streamLabelList = [];
      openAllModal("Live Ping (All ISPs)");
      const rows = document.querySelectorAll("#pulsewatch_table .pulsewatch-row");
      rows.forEach((row) => {
        const addressInput = row.querySelector("input[name$='_address']");
        const sourceIp = addressInput ? (addressInput.value || "").trim() : "";
        if (!sourceIp) {
          return;
        }
        const labelCore = row.querySelector("td:nth-child(1)");
        const labelList = row.querySelector("td:nth-child(2)");
        const identifierInput = row.querySelector("input[name$='_identifier']");
        const identifier = identifierInput ? (identifierInput.value || "").trim() : "";
        const labelValue = identifier || (labelList ? labelList.textContent.trim() : "");
        const label = `${labelCore ? labelCore.textContent.trim() : ""} ${labelValue}`.trim();
        if (label) {
          streamLabelList.push(label);
        }
        const targetsInput = row.querySelector("textarea[name$='_ping_targets']");
        const targets = targetsInput ? (targetsInput.value || "").trim().split("\n").filter((value) => value.trim()) : [];
        const rowId = row.getAttribute("data-row-id") || "";
        if (!rowId) {
          return;
        }
        const panel = ensurePanel(label, targets);
        if (!panel) {
          return;
        }
        if (panel.targetSelect) {
          panel.targetSelect.addEventListener("change", () => {
            panel.pre.textContent = "";
          });
        }
      });
      startStreamAll("/isp/pulsewatch/ping/stream");
    });
  }

  const searchInput = document.getElementById("pulsewatch_search");
  const rows = document.querySelectorAll("#pulsewatch_table .pulsewatch-row");

  const filterRows = () => {
    const query = (searchInput.value || "").toLowerCase();
    rows.forEach((row) => {
      const text = row.textContent.toLowerCase();
      row.style.display = text.includes(query) ? "" : "none";
    });
  };

  if (searchInput) {
    searchInput.addEventListener("input", filterRows);
  }

  const speedtestModal = document.getElementById("pulsewatch_speedtest_modal");
  const speedtestTitle = document.getElementById("pulsewatch_speedtest_title");
  const speedtestDownloadNumber = document.getElementById("pulsewatch_speedtest_download_number");
  const speedtestUploadNumber = document.getElementById("pulsewatch_speedtest_upload_number");
  const speedtestStatus = document.getElementById("pulsewatch_speedtest_status");
  const speedtestDownloadBar = document.getElementById("pulsewatch_speedtest_download_bar");
  const speedtestUploadBar = document.getElementById("pulsewatch_speedtest_upload_bar");
  const speedtestDetails = document.getElementById("pulsewatch_speedtest_details");
  const speedtestLoading = document.getElementById("pulsewatch_speedtest_loading");
  const speedtestServer = document.getElementById("pulsewatch_speedtest_server");
  const speedtestRun = document.getElementById("pulsewatch_speedtest_run");
  const speedtestClose = document.getElementById("pulsewatch_speedtest_close");
  let speedtestTimer = null;
  let speedtestRowId = "";

  const resetSpeedtestUI = () => {
    if (speedtestDownloadNumber) {
      speedtestDownloadNumber.textContent = "0";
    }
    if (speedtestUploadNumber) {
      speedtestUploadNumber.textContent = "0";
    }
    if (speedtestStatus) {
      speedtestStatus.textContent = "Waiting to start…";
    }
    if (speedtestDownloadBar) {
      speedtestDownloadBar.style.width = "0%";
    }
    if (speedtestUploadBar) {
      speedtestUploadBar.style.width = "0%";
    }
    if (speedtestDetails) {
      speedtestDetails.textContent = "Upload: -- Mbps · Ping: -- ms · Server: --";
    }
    if (speedtestLoading) {
      speedtestLoading.style.display = "none";
    }
  };

  const stopSpeedtestAnimation = () => {
    if (speedtestTimer) {
      clearInterval(speedtestTimer);
      speedtestTimer = null;
    }
  };

  const setSpeedtestProcessing = () => {
    stopSpeedtestAnimation();
    if (speedtestLoading) {
      speedtestLoading.style.display = "flex";
    }
    if (speedtestStatus) {
      speedtestStatus.textContent = "Speedtest ongoing…";
    }
    if (speedtestDownloadNumber) {
      speedtestDownloadNumber.textContent = "0";
    }
    if (speedtestUploadNumber) {
      speedtestUploadNumber.textContent = "0";
    }
    if (speedtestDownloadBar) {
      speedtestDownloadBar.style.width = "20%";
    }
    if (speedtestUploadBar) {
      speedtestUploadBar.style.width = "20%";
    }
  };

  const showSpeedtestResult = (download, upload) => {
    stopSpeedtestAnimation();
    if (speedtestLoading) {
      speedtestLoading.style.display = "none";
    }
    if (speedtestDownloadNumber) {
      speedtestDownloadNumber.textContent = (download || 0).toFixed(2);
    }
    if (speedtestUploadNumber) {
      speedtestUploadNumber.textContent = (upload || 0).toFixed(2);
    }
    if (speedtestDownloadBar) {
      speedtestDownloadBar.style.width = "100%";
    }
    if (speedtestUploadBar) {
      speedtestUploadBar.style.width = "100%";
    }
  };

  const openSpeedtestModal = (title) => {
    if (!speedtestModal) {
      return;
    }
    resetSpeedtestUI();
    if (speedtestTitle) {
      speedtestTitle.textContent = title || "Speedtest";
    }
    speedtestModal.style.display = "flex";
  };

  const closeSpeedtestModal = () => {
    if (speedtestModal) {
      speedtestModal.style.display = "none";
    }
    stopSpeedtestAnimation();
  };

  const loadSpeedtestServers = async (rowId) => {
    if (!speedtestServer) {
      return;
    }
    speedtestServer.innerHTML = "<option value=\"\">Automatic</option>";
    speedtestServer.disabled = true;
    try {
      const response = await fetch(`/isp/pulsewatch/speedtest/servers/${rowId}`);
      const data = await response.json();
      if (data && Array.isArray(data.servers)) {
        data.servers.forEach((server) => {
          const option = document.createElement("option");
          option.value = server.id;
          option.textContent = `${server.id} - ${server.label}`;
          speedtestServer.appendChild(option);
        });
      }
    } catch (err) {
      // ignore
    } finally {
      speedtestServer.disabled = false;
    }
  };

  const runSpeedtest = async () => {
    if (!speedtestRowId) {
      return;
    }
    setSpeedtestProcessing();
    const serverId = speedtestServer ? speedtestServer.value : "";
    try {
      const response = await fetch(`/isp/pulsewatch/speedtest/run/${speedtestRowId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ server_id: serverId || null }),
      });
      const data = await response.json();
      if (!data || !data.ok) {
        stopSpeedtestAnimation();
        if (speedtestStatus) {
          speedtestStatus.textContent = data && data.message ? data.message : "Speedtest failed.";
        }
        return;
      }
      const result = data.result || {};
      showSpeedtestResult(result.download_mbps || 0, result.upload_mbps || 0);
      if (speedtestStatus) {
        speedtestStatus.textContent = "Speedtest completed.";
      }
      if (speedtestDetails) {
        const upload = result.upload_mbps != null ? result.upload_mbps : "--";
        const ping = result.latency_ms != null ? result.latency_ms : "--";
        const server = result.server_name || "Auto";
        speedtestDetails.textContent = `Upload: ${upload} Mbps · Ping: ${ping} ms · Server: ${server}`;
      }
    } catch (err) {
      stopSpeedtestAnimation();
      if (speedtestStatus) {
        speedtestStatus.textContent = "Speedtest failed.";
      }
    }
  };

  if (speedtestRun) {
    speedtestRun.addEventListener("click", () => {
      runSpeedtest();
    });
  }
  if (speedtestClose) {
    speedtestClose.addEventListener("click", closeSpeedtestModal);
  }
  if (speedtestModal) {
    speedtestModal.addEventListener("click", (event) => {
      if (event.target === speedtestModal) {
        closeSpeedtestModal();
      }
    });
  }

  const speedtestAllModal = document.getElementById("pulsewatch_speedtest_all_modal");
  const speedtestAllGrid = document.getElementById("pulsewatch_speedtest_all_grid");
  const speedtestAllClose = document.getElementById("pulsewatch_speedtest_all_close");
  const speedtestAllStop = document.getElementById("pulsewatch_speedtest_all_stop");
  const speedtestAllDownload = document.getElementById("pulsewatch_speedtest_all_download");
  const speedtestAllUpload = document.getElementById("pulsewatch_speedtest_all_upload");
  const speedtestAllServer = document.getElementById("pulsewatch_speedtest_all_server");
  const speedtestAllStart = document.getElementById("pulsewatch_speedtest_all_start");
  const speedtestAllStopRun = document.getElementById("pulsewatch_speedtest_all_stop_run");
  const speedtestAllButton = document.getElementById("pulsewatch_speedtest_all");
  let speedtestAllRunning = false;

  const openSpeedtestAllModal = () => {
    if (!speedtestAllModal) {
      return;
    }
    speedtestAllModal.style.display = "flex";
  };

  const closeSpeedtestAllModal = () => {
    speedtestAllRunning = false;
    if (speedtestAllModal) {
      speedtestAllModal.style.display = "none";
    }
    if (speedtestAllGrid) {
      speedtestAllGrid.innerHTML = "";
    }
  };

  const createSpeedtestPanel = (label) => {
    const wrapper = document.createElement("div");
    wrapper.style.border = "1px solid #1f2937";
    wrapper.style.borderRadius = "10px";
    wrapper.style.padding = "12px";
    wrapper.style.background = "#0b1020";
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.gap = "10px";

    const title = document.createElement("strong");
    title.textContent = label;

    const downloadNumber = document.createElement("div");
    downloadNumber.style.fontSize = "32px";
    downloadNumber.style.fontWeight = "700";
    downloadNumber.textContent = "0";

    const downloadLabel = document.createElement("div");
    downloadLabel.style.fontSize = "11px";
    downloadLabel.style.color = "#94a3b8";
    downloadLabel.textContent = "Download Mbps";

    const downloadBarWrap = document.createElement("div");
    downloadBarWrap.style.height = "8px";
    downloadBarWrap.style.background = "#1f2937";
    downloadBarWrap.style.borderRadius = "999px";
    const downloadBar = document.createElement("div");
    downloadBar.style.height = "100%";
    downloadBar.style.width = "0%";
    downloadBar.style.background = "linear-gradient(90deg, #22c55e, #38bdf8)";
    downloadBarWrap.appendChild(downloadBar);

    const uploadNumber = document.createElement("div");
    uploadNumber.style.fontSize = "28px";
    uploadNumber.style.fontWeight = "700";
    uploadNumber.textContent = "0";

    const uploadLabel = document.createElement("div");
    uploadLabel.style.fontSize = "11px";
    uploadLabel.style.color = "#94a3b8";
    uploadLabel.textContent = "Upload Mbps";

    const uploadBarWrap = document.createElement("div");
    uploadBarWrap.style.height = "8px";
    uploadBarWrap.style.background = "#1f2937";
    uploadBarWrap.style.borderRadius = "999px";
    const uploadBar = document.createElement("div");
    uploadBar.style.height = "100%";
    uploadBar.style.width = "0%";
    uploadBar.style.background = "linear-gradient(90deg, #f97316, #facc15)";
    uploadBarWrap.appendChild(uploadBar);

    const status = document.createElement("div");
    status.style.fontSize = "12px";
    status.style.color = "#94a3b8";
    status.textContent = "Waiting…";

    const meta = document.createElement("div");
    meta.style.fontSize = "12px";
    meta.style.color = "#cbd5f5";
    meta.textContent = "Ping: -- ms · Server: --";

    const loading = document.createElement("div");
    loading.style.display = "none";
    loading.style.alignItems = "center";
    loading.style.gap = "8px";
    loading.style.color = "#94a3b8";
    loading.style.fontSize = "12px";
    const spinner = document.createElement("div");
    spinner.style.width = "14px";
    spinner.style.height = "14px";
    spinner.style.border = "2px solid #1f2937";
    spinner.style.borderTopColor = "#38bdf8";
    spinner.style.borderRadius = "50%";
    spinner.style.animation = "spin 0.9s linear infinite";
    const loadingText = document.createElement("div");
    loadingText.textContent = "Speedtest ongoing…";
    loading.appendChild(spinner);
    loading.appendChild(loadingText);

    wrapper.appendChild(title);
    wrapper.appendChild(downloadNumber);
    wrapper.appendChild(downloadLabel);
    wrapper.appendChild(downloadBarWrap);
    wrapper.appendChild(uploadNumber);
    wrapper.appendChild(uploadLabel);
    wrapper.appendChild(uploadBarWrap);
    wrapper.appendChild(status);
    wrapper.appendChild(meta);
    wrapper.appendChild(loading);

    return {
      wrapper,
      downloadNumber,
      uploadNumber,
      downloadBar,
      uploadBar,
      status,
      meta,
      loading,
    };
  };

  const loadSpeedtestAllServers = async (rowId) => {
    if (!speedtestAllServer || !rowId) {
      return;
    }
    speedtestAllServer.innerHTML = "<option value=\"\">Automatic</option>";
    speedtestAllServer.disabled = true;
    try {
      const response = await fetch(`/isp/pulsewatch/speedtest/servers/${rowId}`);
      const data = await response.json();
      if (data && Array.isArray(data.servers)) {
        data.servers.forEach((server) => {
          const option = document.createElement("option");
          option.value = server.id;
          option.textContent = `${server.id} - ${server.label}`;
          speedtestAllServer.appendChild(option);
        });
      }
    } catch (err) {
      // ignore
    } finally {
      speedtestAllServer.disabled = false;
    }
  };

  const runSpeedtestAll = async () => {
    if (!speedtestAllGrid || !speedtestAllDownload || !speedtestAllUpload) {
      return;
    }
    speedtestAllGrid.innerHTML = "";
    speedtestAllDownload.textContent = "Total Download: -- Mbps";
    speedtestAllUpload.textContent = "Total Upload: -- Mbps";
    speedtestAllRunning = true;

    const rows = Array.from(document.querySelectorAll("#pulsewatch_table .pulsewatch-row")).filter((row) => {
      const addressInput = row.querySelector("input[name$='_address']");
      return addressInput && (addressInput.value || "").trim().length > 0;
    });

    const panels = rows.map((row) => {
      const labelCore = row.querySelector("td:nth-child(1)");
      const labelList = row.querySelector("td:nth-child(2)");
      const identifierInput = row.querySelector("input[name$='_identifier']");
      const identifier = identifierInput ? (identifierInput.value || "").trim() : "";
      const labelValue = identifier || (labelList ? labelList.textContent.trim() : "");
      const label = `${labelCore ? labelCore.textContent.trim() : ""} ${labelValue}`.trim();
      const panel = createSpeedtestPanel(label || "ISP");
      speedtestAllGrid.appendChild(panel.wrapper);
      return { rowId: row.getAttribute("data-row-id"), panel };
    });

    let totalDownload = 0;
    let totalUpload = 0;
    const selectedServer = speedtestAllServer ? speedtestAllServer.value : "";

    for (const entry of panels) {
      if (!speedtestAllRunning) {
        break;
      }
      entry.panel.wrapper.style.borderColor = "#38bdf8";
      entry.panel.wrapper.style.animation = "glow 1.2s ease-in-out infinite";
      entry.panel.loading.style.display = "flex";
      entry.panel.status.textContent = "Running…";

      const response = await fetch(`/isp/pulsewatch/speedtest/run/${entry.rowId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ server_id: selectedServer || null }),
      });
      const data = await response.json();
      entry.panel.loading.style.display = "none";
      entry.panel.wrapper.style.borderColor = "#1f2937";
      entry.panel.wrapper.style.animation = "none";

      if (data && data.ok) {
        const result = data.result || {};
        const download = result.download_mbps || 0;
        const upload = result.upload_mbps || 0;
        entry.panel.downloadNumber.textContent = download.toFixed(2);
        entry.panel.uploadNumber.textContent = upload.toFixed(2);
        entry.panel.downloadBar.style.width = "100%";
        entry.panel.uploadBar.style.width = "100%";
        entry.panel.status.textContent = "Completed.";
        const ping = result.latency_ms != null ? result.latency_ms : "--";
        const server = result.server_name || "Auto";
        entry.panel.meta.textContent = `Ping: ${ping} ms · Server: ${server}`;
        totalDownload += download;
        totalUpload += upload;
      } else {
        entry.panel.status.textContent = data && data.message ? data.message : "Failed.";
      }
    }

    if (speedtestAllRunning) {
      speedtestAllDownload.textContent = `Total Download: ${totalDownload.toFixed(2)} Mbps`;
      speedtestAllUpload.textContent = `Total Upload: ${totalUpload.toFixed(2)} Mbps`;
    }
    speedtestAllRunning = false;
  };

  if (speedtestAllButton) {
    speedtestAllButton.addEventListener("click", () => {
      openSpeedtestAllModal();
      const firstRow = document.querySelector("#pulsewatch_table .pulsewatch-row");
      if (firstRow) {
        loadSpeedtestAllServers(firstRow.getAttribute("data-row-id"));
      }
    });
  }
  if (speedtestAllStart) {
    speedtestAllStart.addEventListener("click", () => {
      if (speedtestAllRunning) {
        return;
      }
      runSpeedtestAll();
    });
  }
  if (speedtestAllStopRun) {
    speedtestAllStopRun.addEventListener("click", () => {
      speedtestAllRunning = false;
    });
  }
  if (speedtestAllClose) {
    speedtestAllClose.addEventListener("click", closeSpeedtestAllModal);
  }
  if (speedtestAllStop) {
    speedtestAllStop.addEventListener("click", closeSpeedtestAllModal);
  }
  if (speedtestAllModal) {
    speedtestAllModal.addEventListener("click", (event) => {
      if (event.target === speedtestAllModal) {
        closeSpeedtestAllModal();
      }
    });
  }

  const speedtestButtons = document.querySelectorAll(".pulsewatch-speedtest");
  speedtestButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const rowId = button.getAttribute("data-row-id");
      if (!rowId) {
        return;
      }
      const row = button.closest("tr");
      const labelCore = row ? row.querySelector("td:nth-child(1)") : null;
      const labelList = row ? row.querySelector("td:nth-child(2)") : null;
      const identifierInput = row ? row.querySelector("input[name$='_identifier']") : null;
      const identifier = identifierInput ? (identifierInput.value || "").trim() : "";
      const labelValue = identifier || (labelList ? labelList.textContent.trim() : "");
      const label = `${labelCore ? labelCore.textContent.trim() : ""} ${labelValue}`.trim();
      speedtestRowId = rowId;
      openSpeedtestModal(`Speedtest - ${label || rowId}`);
      loadSpeedtestServers(rowId);
      runSpeedtest();
    });
  });

  const table = document.getElementById("pulsewatch_table");
  if (table) {
    const headers = table.querySelectorAll("thead th[data-sort]");
    const tbody = table.querySelector("tbody");
    const sortState = {};

    const getCellValue = (row, index) => {
      const cell = row.children[index];
      if (!cell) {
        return "";
      }
      const input = cell.querySelector("input, textarea");
      if (input) {
        return (input.value || "").trim();
      }
      return (cell.textContent || "").trim();
    };

    headers.forEach((header, index) => {
      header.addEventListener("click", () => {
        const type = header.getAttribute("data-sort") || "text";
        const current = sortState[index] || "asc";
        const next = current === "asc" ? "desc" : "asc";
        sortState[index] = next;

        const sorted = Array.from(tbody.querySelectorAll("tr.pulsewatch-row"));
        sorted.sort((a, b) => {
          const aVal = getCellValue(a, index);
          const bVal = getCellValue(b, index);
          if (type === "number") {
            const aNum = parseFloat(aVal) || 0;
            const bNum = parseFloat(bVal) || 0;
            return next === "asc" ? aNum - bNum : bNum - aNum;
          }
          const compare = aVal.localeCompare(bVal, undefined, { numeric: true, sensitivity: "base" });
          return next === "asc" ? compare : -compare;
        });

        sorted.forEach((row) => tbody.appendChild(row));
      });
    });
  }

  const recommendationAlert = document.getElementById("pulsewatch_recommendation_alert");
  if (recommendationAlert) {
    const clearBtn = document.getElementById("pulsewatch_recommendation_clear");
    const applyBtn = document.getElementById("pulsewatch_recommendation_apply");
    const closeBtn = document.getElementById("pulsewatch_recommendation_close");
    const dismissAlert = () => {
      recommendationAlert.remove();
    };
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        document.querySelectorAll("input[data-recommended='1']").forEach((input) => {
          input.value = "";
          input.removeAttribute("data-recommended");
        });
        dismissAlert();
      });
    }
    if (applyBtn) {
      applyBtn.addEventListener("click", () => {
        dismissAlert();
      });
    }
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        dismissAlert();
      });
    }
  }
</script>
{% endblock %}
